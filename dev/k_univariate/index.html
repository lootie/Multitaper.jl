<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Univariate Functions · Multitaper.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Multitaper.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Multitaper.jl Documentation</a></li><li><a class="tocitem" href="../j_manual/">User manual</a></li><li class="is-active"><a class="tocitem" href>Univariate Functions</a><ul class="internal"><li><a class="tocitem" href="#Quick-Synopsis-of-Capabilities"><span>Quick Synopsis of Capabilities</span></a></li><li><a class="tocitem" href="#Univariate-spectrum-estimation"><span>Univariate spectrum estimation</span></a></li><li><a class="tocitem" href="#Time-domain-statistics"><span>Time domain statistics</span></a></li><li><a class="tocitem" href="#Missing-data-Spectrum"><span>Missing-data Spectrum</span></a></li></ul></li><li><a class="tocitem" href="../l_multivariate/">Multivariate Functions</a></li><li><a class="tocitem" href="../lib/public/">Function index</a></li><li><a class="tocitem" href="../m_plotting/">Plotting</a></li><li><a class="tocitem" href="../n_examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Univariate Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Univariate Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lootie/Multitaper.jl/blob/master/docs/src/k_univariate.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Univariate-Functions"><a class="docs-heading-anchor" href="#Univariate-Functions">Univariate Functions</a><a id="Univariate-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-Functions" title="Permalink"></a></h1><p>The univariate functionality of this package computes multitaper estimates of the power spectrum, autocorrelation, cepstrum, and complex demodulation of a time series. One can also estimate the power spectrum when there is missing data.  </p><p>An estimate of the power spectral density contains information about the sample variance of the time series, decomposed in terms of frequency. When the multitaper method is used, multiple tapering functions ensure that the statistical bias-variance tradeoff is optimized.  Discrete prolate spheroidal sequences, which are used as tapering functions, are finite-length sequences whose Fourier transforms contain most of their power on a narrow bandwidth. This property makes them optimal for reducing spectral leakage. The orthogonality of the tapering functions also means that one can compute empirical confidence intervals for the spectrum estimate by jackknifing, and estimate the significance of discrete sinusoids using an F-test.  Finally, one can compute the quantities above when time series are sampled on a regular grid for which there are missing data points. </p><p>Cepstrum analysis is widely used in speech processing applications and for deconvolution. Complex demodulation of a time series allows for examination of the amplitude and phase of a sinusoid at a frequency of interest to the time series being studied. </p><h2 id="Quick-Synopsis-of-Capabilities"><a class="docs-heading-anchor" href="#Quick-Synopsis-of-Capabilities">Quick Synopsis of Capabilities</a><a id="Quick-Synopsis-of-Capabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Synopsis-of-Capabilities" title="Permalink"></a></h2><p>Univariate</p><ul><li><p>Discrete Prolate Spheroidal sequences</p></li><li><p>Multitaper spectra that use dpss (multispec) tapers</p></li><li><p>Jackknifing</p></li></ul><h2 id="Univariate-spectrum-estimation"><a class="docs-heading-anchor" href="#Univariate-spectrum-estimation">Univariate spectrum estimation</a><a id="Univariate-spectrum-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-spectrum-estimation" title="Permalink"></a></h2><h3 id="multispec"><a class="docs-heading-anchor" href="#multispec">multispec</a><a id="multispec-1"></a><a class="docs-heading-anchor-permalink" href="#multispec" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Multitaper.multispec-Tuple{Any}" href="#Multitaper.multispec-Tuple{Any}"><code>Multitaper.multispec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multispec(S1; &lt;keyword arguments&gt;)</code></pre><p>Computes univariate multitaper spectra with a handful of extra gadgets. </p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>S1::Vector{T} where T&lt;:Float64</code>: the vector containing the time series</li><li><code>NW::Float64 = 4.0</code>: time-bandwidth product of estimate</li><li><code>K::Int64 = 6</code>: number of slepian tapers, must be &lt;= 2*NW</li><li><code>dt::Float64</code>: sampling rate in time units </li><li><code>ctr::Bool</code>: whether or not to remove the mean before computing the multitaper spectrum</li><li><code>pad::Float64 = 1.0</code>: factor by which to pad the series, i.e. spectrum length will be pad times length of the time series.</li><li><code>dpVec::Union{Matrix{Float64},Nothing} = nothing</code>: Matrix of dpss&#39;s, if they have been precomputed</li><li><code>egval::Union{Vector{Float64},Nothing} = nothing</code>: Vector of concentratins of said dpss&#39;s</li><li><code>guts::Bool = false</code>: whether or not to return the eigencoefficients in the output struct</li><li><code>a_weight::Bool = true</code>: whether or not to use adaptive weighting</li><li><code>Ftest::Bool = true</code>: Compute the F-test p-value</li><li><code>highres::Bool = false</code>: Whether to return a &quot;high resolution&quot; spectrum estimate</li><li><code>jk::Bool = true</code>: Compute jackknifed confidence intervals</li><li><code>Tsq::Union{Vector{Int64},Vector{Vector{Int64}},Nothing} = nothing</code>: which frequency indices to compute the T-squared test for multiple line components. Defaults to none.</li></ul><p>...</p><p>...</p><p><strong>Outputs</strong></p><ul><li><code>MTSpectrum</code> struct containing the spectrum</li></ul><p>...</p><p>See also: <a href="#Multitaper.dpss_tapers"><code>dpss_tapers</code></a>, <a href="#Multitaper.MTSpectrum"><code>MTSpectrum</code></a>, <a href="#Multitaper.mdmultispec"><code>mdmultispec</code></a>, <a href="#Multitaper.mdslepian"><code>mdslepian</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lootie/Multitaper.jl/blob/3e023216423a857a00eb1db8c456405054a7d291/src/Univariate.jl#L243-L272">source</a></section><section><div><pre><code class="nohighlight hljs">multispec(S1; &lt;keyword arguments&gt;)</code></pre><p>Multivariate version of the multispec call, data are in the columns of a matrix ...</p><p><strong>Arguments</strong></p><ul><li><code>S1::Matrix{T} where T&lt;:Float64</code>: the vector containing the first time series</li><li><code>outp::Symbol</code>: output can be either :coh for coherence, :justspeccs to compute just the spectra, or :cross for cross-spectra</li><li><code>NW::Float64 = 4.0</code>: time-bandwidth product of estimate</li><li><code>K::Int64 = 6</code>: number of slepian tapers, must be &lt;= 2*NW</li><li><code>dt::Float64</code>: sampling rate in time units </li><li><code>ctr::Bool</code>: whether or not to remove the mean before computing the multitaper spectrum</li><li><code>pad::Float64 = 1.0</code>: factor by which to pad the series, i.e. spectrum length will be pad times length of the time series.</li><li><code>dpVec::Union{Matrix{Float64},Nothing} = nothing</code>: Matrix of dpss&#39;s, if they have been precomputed</li><li><code>guts::Bool = false</code>: whether or not to return the eigencoefficients in the output struct</li><li><code>a_weight::Bool = true</code>: whether or not to adaptively weight the spectra</li><li><code>jk::Bool = false</code>: Compute jackknifed confidence intervals</li><li><code>Ftest:Bool = false</code>: Compute F-test for line components</li><li><code>Tsq::Union{Vector{Int64},Vector{Vector{Int64}},Nothing} = nothing</code>: which frequency indices to compute the T-squared test for multiple line components. Defaults to none.</li><li><code>alph::Float64 = 0.05</code>: significance cutoff for the Tsquared test</li></ul><p>...</p><p>...</p><p><strong>Outputs</strong></p><ul><li><code>Tuple{Vector{MTSpectrum},Vector{P},Union{Float64,Vector{Float64}}} where P = Union{MTCoherence,MTSpectrum}</code> </li></ul><p>struct containing the spectra, coherence or crossspectra, and Tsquared test p-values.  Ouput of middle arg depends on the selection of <code>outp</code> input.  ...</p><p>See also: <a href="#Multitaper.dpss_tapers"><code>dpss_tapers</code></a>, <a href="#Multitaper.MTSpectrum"><code>MTSpectrum</code></a>, <a href="#Multitaper.mdmultispec"><code>mdmultispec</code></a>, <a href="#Multitaper.mdslepian"><code>mdslepian</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lootie/Multitaper.jl/blob/3e023216423a857a00eb1db8c456405054a7d291/src/Multivariate.jl#L244-L274">source</a></section></article><p>This command does a lot of the univariate stuff. Its signature is:</p><pre><code class="nohighlight hljs">function multispec(S1::Union{Vector{T}}; 
                   NW::Real = 4.0, 
                   K::Int = 6, 
                   dt::Float64 = 1.0, 
                   ctr::Bool = true, 
                   pad::Union{Int,Float64} = 1.0, 
                   dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing,
                   egval::Union{Vector{Float64},Nothing} = nothing,
                   guts::Bool = false, 
                   a_weight::Bool = true, 
                   Ftest::Bool = false, 
                   highres::Bool = false,
                   jk::Bool = false, 
                   Tsq::Union{Vector{Float64},Vector{Vector{Float64}},
                      Vector{Int64},Vector{Vector{Int64}},Nothing} = nothing, 
                   alph::Float64 = 0.05
                  ) where T&lt;:Number</code></pre><p>S1 is the time series, and you have the following keyword options:</p><ul><li>NW, the choice of time-bandwidth product</li><li>K, the number of tapers to use</li><li>dt, the temporal sampling frequency (in, say, seconds)</li><li>ctr, whether or not to remove the mean from the data series, default is true</li><li><code>pad</code>, the padded length will be pad times the length of S1.  </li><li>dpVec, you can choose to supply the dpss&#39;s or not (speeds things up if you&#39;re calling the function many times)</li><li>egval, eigenvalues associated with the vectors above, optional</li><li>guts, whether you&#39;d like the eigencoefficients as output. They will come in an eigencoefficient struct with the field coef, wts where coef contains the eigencoefficients and wts will contain the adaptive weights</li><li>a_weight, whether to use the adaptive weighting scheme described in Thomson, 1982</li><li>Ftest, whether to compute the harmonic F-test described in Thomson, 1982</li><li>highres, whether the estimate should be a high-resolution estimate, see Thomson 1982</li><li>jk, jackknifing to give a confidence interval for the spectrum</li><li>Tsq, T-squared test for multiple line components (Thomson Asilomar conference proceedings)</li><li>alph, confidence level for jackknife confidence intervals and Tsq tests.</li></ul><p>The output of this command is a MTSpectrum struct which contains the following fields (in the following order):</p><ul><li>frequency (f), as a LinRange</li><li>spectrum (S), a vector giving half the spectrum up to the Nyquist if the input is real</li><li>phase (optional), </li><li>chosen values of the multitaper time bandwidth product etc of type MTParameters (params) This makes its own parameter struct that contains NW, K, N, dt, M (padded</li></ul><p>length), nsegments (number of segments of data to averae), overlap (if the sample was   divided into overlapping chunks) and it gets carried around for future reference and   for plotting purposes</p><ul><li>eigencoefficients (coef, optional), </li><li>Ftest values (Fpval, optional), </li><li>jackknife output (jkvar, optional), and</li><li>Tsquared test results (Tsq_pval, optional). </li></ul><p>Some of the fields will contain nothing, or if you requested one of the jacknifed confidence interval (<code>jk = true</code>), F-test for line components (<code>Ftest = true</code>), multivariate T^2 test for line components (<code>Tsq != nothing</code>), or the eigencoefficients and possibly adaptive weights (<code>guts=true</code>), then the relevant fields in the output struct will be filled. </p><p>Note that <code>pad</code> here can be given in two different ways: if it is a float, then it is the factor by which to multiply the length of the original data sequence, and if it is an integer larger than the length of the original data sequence, it will be the number of data points in the full FFT.</p><p>If dpVec is given, you have supplied pre-computed Slepians, which will speed things up if the function is going to be called many times.  The option <code>a_weight</code> uses adaptive weighting. </p><p>A note on plotting: if you are using Plots.jl there are pre-loaded recipes that make plotting of MTSpectrum structs completely trivial. Simply plot your MTSpectrum structs as if they were vectors, and you&#39;ll get a bunch of preformatting for free. Consult the jupyter notebooks for examples of some of the recipes.</p><h3 id="Welch"><a class="docs-heading-anchor" href="#Welch">Welch</a><a id="Welch-1"></a><a class="docs-heading-anchor-permalink" href="#Welch" title="Permalink"></a></h3><p>The welch estimate of the spectrum is one that is an average of multitaper spectra computed on overlapping data blocks. You&#39;d call the function like this</p><pre><code class="nohighlight hljs">welch(S1::Union{Vector{Float64}, Vector{ComplexF64}, Matrix{Float64}, 
               Matrix{ComplexF64}}, 
               nsegments::Int64, overlap::Float64 = 0.5, ws::Symbol = :welch; 
               outp::Symbol = :spec,
               NW::Real = 4.0, K::Int = 6, dt::Float64 = 1.0,
               ctr::Bool = true, pad::Union{Int,Float64} = 1.0,
               dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing, 
               egval::Union{Vector{Float64},Nothing} = nothing, 
               guts::Bool = false, a_weight::Bool = true, Ftest::Bool = false, 
               jk::Bool = false, 
               Tsq::Union{Array{Int64,1},Array{Array{Int64,1},1},Nothing}=nothing,
               alph::Float64 = 0.05) </code></pre><p>The call is very similar to the multispec call above, except you will enter the parameters nsegments and overlap, that is, the number of data blocks to make, and the overlap between them. Since there is some fudging these numbers, you will get the number of segments and overlap back in the params field of the output struct. The ws toggle is by default set to :welch mode, but this code is also the backbone for a spectrogram, which is why this keyword argument is here. </p><p>Note that this function returns a tuple: the first argument is a <code>MTSpectrum</code> object, and the second is the <em>effective bandwidth</em> (See Thomson and Chave 1991).</p><h2 id="Time-domain-statistics"><a class="docs-heading-anchor" href="#Time-domain-statistics">Time domain statistics</a><a id="Time-domain-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Time-domain-statistics" title="Permalink"></a></h2><h3 id="mt_acvf"><a class="docs-heading-anchor" href="#mt_acvf">mt_acvf</a><a id="mt_acvf-1"></a><a class="docs-heading-anchor-permalink" href="#mt_acvf" title="Permalink"></a></h3><p>This function computes multitaper estimates of the covariance, correlation, and cepstrum, by way of inverse-FFT of a multitaper spectrum estimate. Its signature is either</p><pre><code class="nohighlight hljs">function mt_acvf(S::MTSpectrum)</code></pre><p>or</p><pre><code class="nohighlight hljs">function mt_acvf(S1::Union{Vector{T}}; 
                 NW::Real = 4.0, 
                 K::Int = 6, 
                 dt::Float64=1.0, 
                 ctr::Bool = true, 
                 pad::Union{Int,Float64} = 1.0, 
                 dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing,
                 egval::Union{Vector{Float64},Nothing} = nothing,
                 a_weight::Bool = true, 
                 reshape::Union{Bool, Float64, Int64, Vector{Float64}, 
                          Vector{Int64}} = false,
                 ) where T&lt;:Number</code></pre><p>The first method is used if you&#39;ve already computed the spectrum and have the MTSpectrum struct handy.  If not, you can use the second version, putting in the time series, and using any other relevant input arguments mentioned in the multispec call above.</p><p>The output is</p><ul><li>MTAutocorrelationFunction: Contains lags, autocorrelation function, and a params struct (mentioned above) that carries around the relevant multitaper options. </li></ul><h3 id="mt_acf"><a class="docs-heading-anchor" href="#mt_acf">mt_acf</a><a id="mt_acf-1"></a><a class="docs-heading-anchor-permalink" href="#mt_acf" title="Permalink"></a></h3><p>This function computes multitaper estimates of the correlation by way of inverse-FFT of a multitaper spectrum estimate. Its signature is either</p><pre><code class="nohighlight hljs">function mt_acf(S::MTSpectrum)</code></pre><p>or</p><pre><code class="nohighlight hljs">function mt_acf(S1::Union{Vector{T}}; 
                 NW::Real = 4.0, 
                 K::Int = 6, 
                 dt::Float64=1.0, 
                 ctr::Bool = true, 
                 pad::Union{Int,Float64} = 1.0, 
                 dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing,
                 egval::Union{Vector{Float64},Nothing} = nothing,
                 a_weight::Bool = true, 
                 reshape::Union{Bool, Float64, Int64, Vector{Float64}, 
                          Vector{Int64}} = false,
                 ) where T&lt;:Number</code></pre><p>The first method is used if you&#39;ve already computed the spectrum and have the MTSpectrum struct handy.  If not, you can use the second version, putting in the time series, and using any other relevant input arguments mentioned in the multispec call above.</p><p>The output is</p><ul><li>MTAutocovarianceFunction: Contains lags, autocovariance function, and a params struct.</li></ul><h3 id="mt_cepstrum"><a class="docs-heading-anchor" href="#mt_cepstrum"><code>mt_cepstrum</code></a><a id="mt_cepstrum-1"></a><a class="docs-heading-anchor-permalink" href="#mt_cepstrum" title="Permalink"></a></h3><p>This function computes multitaper estimate of the cepstrum, by way of inverse-FFT of the logarithm of a multitaper spectrum estimate. Its signature is either</p><pre><code class="nohighlight hljs">function mt_cepstrum(S::MTSpectrum)</code></pre><p>or</p><pre><code class="nohighlight hljs">function mt_cepstrum(S1::Union{Vector{T}}; 
                 NW::Real = 4.0, 
                 K::Int = 6, 
                 dt::Float64=1.0, 
                 ctr::Bool = true, 
                 pad::Union{Int,Float64} = 1.0, 
                 dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing,
                 egval::Union{Vector{Float64},Nothing} = nothing,
                 a_weight::Bool = true, 
                 reshape::Union{Bool, Float64, Int64, Vector{Float64}, 
                          Vector{Int64}} = false,
                 ) where T&lt;:Number</code></pre><p>The first method is used if you&#39;ve already computed the spectrum and have the MTSpectrum struct handy.  If not, you can use the second version, putting in the time series, and using any other relevant input arguments mentioned in the multispec call above.</p><p>The output is</p><ul><li><code>MTCepstrum</code>: Contains lags (quefrency), a cepstrum estimate, and a params struct. The cepstrum is the inverse-FFT (or cosine transform, when the signal is real) of the</li></ul><p>logarithm of the spectrum. </p><p>When you plot one of the <code>MTAutocorrelationFunction</code>, <code>MTAutocovarianceFunction</code>, or <code>MTCepstrum</code> structs using the recipe, you&#39;ll get a stem plot. </p><h3 id="demodulate"><a class="docs-heading-anchor" href="#demodulate"><code>demodulate</code></a><a id="demodulate-1"></a><a class="docs-heading-anchor-permalink" href="#demodulate" title="Permalink"></a></h3><p>This function computes the multitaper estimate of the complex demodulate. Note that there are several published implementations of this, but this one uses a single zeroth order Slepian taper as a filter. Note that this is identical to the implementation in the R multitaper package. The function signature is </p><pre><code class="nohighlight hljs">function demodulate(x::Vector{Float64}, f0::Float64, NW::Float64, blockLen::Int64, 
                    wrapphase::Bool = true, dt::Float64, basetime::Float64)</code></pre><p>The inputs are the following:</p><ul><li><code>x</code> is the data vector to be demodulated</li><li><code>dt</code> is the sampling rate (in years, for example)</li><li><code>f0</code> is the center frequency (e.g. one cycle per year)</li><li><code>NW</code> is the time-bandwidth product for the filter (typically narrow, use a float)</li><li><code>blockLen</code> is a subjective length to use for the data filter, note that the output  will be shortened by this amount, so a short filter is sometimes better. </li><li><code>wrapphase</code> is an optional boolean which tells the algorithm whether or not to  unwrap the phase for pretty plotting. </li><li><code>basetime</code> is the time for the first time index</li></ul><p>The output will be a <code>Demodulate</code> struct containing time (time), magnitude (mag), and phase (phase).  For easy plotting there is a Plots.jl recipe. See also the notebook <a href="https://bitbucket.org/clhaley/multitaper.jl/src/master/Examples/04_Demodulation.ipynb?at=master&amp;viewer=nbviewer">04_Demodulation.ipynb</a> in the Examples directory for usage.  </p><h2 id="Missing-data-Spectrum"><a class="docs-heading-anchor" href="#Missing-data-Spectrum">Missing-data Spectrum</a><a id="Missing-data-Spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-data-Spectrum" title="Permalink"></a></h2><h3 id="mdmultispec"><a class="docs-heading-anchor" href="#mdmultispec"><code>mdmultispec</code></a><a id="mdmultispec-1"></a><a class="docs-heading-anchor-permalink" href="#mdmultispec" title="Permalink"></a></h3><p>Chave showed how to compute dpss&#39;s and multitaper spectra on data with gaps <a href="https://academic.oup.com/gji/article-abstract/218/3/2165/5519233">(Chave,2019)</a>. The function signature is </p><pre><code class="nohighlight hljs">function mdmultispec(tt::Union{Vector{Int64},Vector{Float64}}, x::Vector{Float64}; 
                bw=5/length(tt), k=Int64(2*bw*size(x,1)-1), 
                lambdau::Union{Tuple{Array{Float64,1},
                               Array{Float64,2}},Nothing} = nothing,
                dt=tt[2]-tt[1], nz=0, Ftest=true, jk=true,
                dof=false)</code></pre><p>The inputs are the following:</p><ul><li><code>tt</code> – real vector of time (required)</li><li><code>x</code> – real vector of data (required)</li><li><code>bw</code> – bandwidth of estimate, 5/length(t) default</li><li><code>k</code> – number of slepian tapers, must be &lt;=2 bw length(x), 2 bw length(x)-1 default</li><li><code>lambdau</code> – missing data Slepian tapers and their concentrations, if precomputed</li><li><code>dt</code> – sampling in time</li><li><code>nz</code> – zero padding factor, 0 default</li><li><code>Ftest</code> – whether or not to compute the F-test p-value at all frequencies</li><li><code>jk</code> – whether or not to compute jackknife variance estimates</li><li><code>dof</code> – whether or not to output the degrees of freedom of the estimate</li></ul><p>The outputs are simply a list of the following </p><ul><li><code>sxx</code> – MTSpectrum spectrum </li><li><code>nu1</code> – Degrees of freedom, if dof is set to true</li></ul><h3 id="mdslepian"><a class="docs-heading-anchor" href="#mdslepian"><code>mdslepian</code></a><a id="mdslepian-1"></a><a class="docs-heading-anchor-permalink" href="#mdslepian" title="Permalink"></a></h3><p>One can also simply generate Slepian tapers for the missing data problem using the <code>mdslepian</code> function. Its function signature is </p><pre><code class="nohighlight hljs">function mdslepian(w, k, t)</code></pre><p>The inputs are the following:</p><ul><li><code>w</code> – the bandwidth of the taper</li><li><code>k</code> – the number of Slepian tapers</li><li><code>t</code> – the vector containing the time indicees</li></ul><p>The outputs are</p><ul><li><code>lambda</code> – the concentrations of the missing-data Slepians</li><li><code>u</code> – length(t) times k matrix containing the missing-data Slepians</li></ul><h3 id="gpss"><a class="docs-heading-anchor" href="#gpss"><code>gpss</code></a><a id="gpss-1"></a><a class="docs-heading-anchor-permalink" href="#gpss" title="Permalink"></a></h3><p>Following the work of  <a href="https://ieeexplore.ieee.org/abstract/document/9031">(Bronez, 1988</a>, one can compute optimally concentrated data tapers on a general, uneven, temporal grid. These are called generalized prolate spheroidal sequences. The function with the following signature computes these</p><pre><code class="nohighlight hljs">function gpss(w::Float64, k::Int64, t::Union{Vector{Int64},Vector{Float64}}, 
        f::Float64; beta::Float64 = 0.5)</code></pre><p>The inputs are the following:</p><ul><li><code>w</code> – the bandwidth of the taper</li><li><code>k</code> – the number of Slepian tapers</li><li><code>t</code> – the vector containing the time indicees</li><li><code>f</code> – the frequency of interest, between 0 and beta</li><li><code>beta</code> – the unequal sampling equivalent to the Nyquist rate</li></ul><p>The outputs are</p><ul><li><code>lambda</code> – the concentrations of the missing-data Slepians</li><li><code>u</code> – length(t) times k matrix containing the missing-data Slepians</li><li><code>R</code> – Cholesky factor for the generalized eigenvalue problem</li></ul><p>!!! This function is known to occasionally have numerical errors in computing the Cholesky factors of the genealized eigenvalue problem, so use at own risk. For the cases we tested, however, this function generally returns the expected result.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../j_manual/">« User manual</a><a class="docs-footer-nextpage" href="../l_multivariate/">Multivariate Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Thursday 23 September 2021 16:41">Thursday 23 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
