var documenterSearchIndex = {"docs":
[{"location":"lib/public/#Function-index","page":"Function index","title":"Function index","text":"","category":"section"},{"location":"lib/public/#Public-types-and-functions","page":"Function index","title":"Public types and functions","text":"","category":"section"},{"location":"lib/public/#Structs","page":"Function index","title":"Structs","text":"","category":"section"},{"location":"lib/public/","page":"Function index","title":"Function index","text":"MTSpectrum\nMTCoherence\nMTTransferFunction\nEigenCoefficient\nMTParameters\nDemodulate\nMTAutocorrelationFunction\nMTAutocovarianceFunction\nMTCepstrum\nMtCrossCovarianceFunction\nMTCrossCorrelationFunction","category":"page"},{"location":"lib/public/#Multitaper.MTSpectrum","page":"Function index","title":"Multitaper.MTSpectrum","text":"The multitaper spectrum is given as a MTSpectrum structure which holds \n\nfrequency (f), \nspectrum (S), \nphase (optional), \nchosen values of the multitaper time bandwidth product etc of type MTParameters (params)\neigencoefficients (coef, optional), \nFtest values (Fpval, optional), \njackknife output (jkvar, optional), and\nTsquared test results (Tsq_pval, optional). \n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Multitaper.MTCoherence","page":"Function index","title":"Multitaper.MTCoherence","text":"The multitaper coherence structure, MTCoherence, holds \n\nfrequency (f), \ncoherence (coh), \nphase (phase), \neigencoefficients (coef, optional), \njackknife output (jkvar, optional), and \nTsquared test results (Tsq, optional).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Multitaper.MTTransferFunction","page":"Function index","title":"Multitaper.MTTransferFunction","text":"The multitaper transfer function is given as a MTTransferFunction structure which holds \n\nfrequency (f), \ntransfer function (transf), \nphase (phase), \nMTParameters (params),\neigencoefficients (EigenCoefficientfs, optional), \njackknife output (jkvar, optional), and \nTsquared test results (Tsq, optional).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Multitaper.EigenCoefficient","page":"Function index","title":"Multitaper.EigenCoefficient","text":"The EigenCoefficient structure holds \n\nmultitaper eigencoefficients (coef) and, optionally, \nadaptive weights (wts) \n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Multitaper.MTParameters","page":"Function index","title":"Multitaper.MTParameters","text":"Multitaper parameters MTParameters struct contains\n\ntime bandwidth (NW) as Float, \nnumber of tapers (K), \nnumber of samples (N), \nsampling rate (dt) in temporal units (e.g. seconds), \npadded length (M), \nnumber of segments (nsegments), and \noverlap if nsegments is greater than 1, nothing otherwise.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Multitaper.Demodulate","page":"Function index","title":"Multitaper.Demodulate","text":"Multitaper complex demodulates are held in the Demodulate struct which contains\n\nmagnitude (Mag), \nphase (Phase)\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Multitaper.MTAutocorrelationFunction","page":"Function index","title":"Multitaper.MTAutocorrelationFunction","text":"The multitaper autocorrelation function is given in the MTAutocorrelationFunction structure which holds \n\nlags (lags), \nautocorrelation function (acf), \nMTParameters (params)\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Multitaper.MTAutocovarianceFunction","page":"Function index","title":"Multitaper.MTAutocovarianceFunction","text":"The multitaper autocovariance function is given in the MTAutocovarianceFunction structure, which holds\n\nlags (lags), \nautocovariance function (acvf), \nMTParameters (params)\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Multitaper.MTCepstrum","page":"Function index","title":"Multitaper.MTCepstrum","text":"The multitaper cepstrum is given in the MTCepstrum structure which holds \n\nlags (lags), \ncepstrum (ceps), \nMTParameters (params)\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Multitaper.MtCrossCovarianceFunction","page":"Function index","title":"Multitaper.MtCrossCovarianceFunction","text":"The multitaper cross-covariance function is given in the MtCrossCovarianceFunction structure which holds \n\nlags (lags), \ncross-covariance function (acvf), \nMTParameters (params)\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Multitaper.MTCrossCorrelationFunction","page":"Function index","title":"Multitaper.MTCrossCorrelationFunction","text":"The multitaper cross-correlation function is given as a MTCrossCorrelationFunction structure which holds \n\nlags (lags), \ncross-correlation function (acf), \nMTParameters (params)\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Taper-functions","page":"Function index","title":"Taper functions","text":"","category":"section"},{"location":"lib/public/","page":"Function index","title":"Function index","text":"dpss_tapers\nmdslepian\ngpss","category":"page"},{"location":"lib/public/#Multitaper.dpss_tapers","page":"Function index","title":"Multitaper.dpss_tapers","text":"dpss_tapers(n,w,k,tap_or_egval)\n\nSimply compute discrete prolate spheroidal sequence tapers, eigenvalues \n\n...\n\nArguments\n\nn::Int64: Length of the taper\nnw::Float64: Time-bandwidth product\nk::Int64: Number of tapers\ntap_or_egval::Symbol = :tap: Either :tap, :egval, or :both\n\n...\n\n...\n\nOutputs\n\nvv::Vector{Float64}: The matrix of eigenvalues, if taporegval is set to :tap\ndpss_eigval: Struct conaining the dpss tapers\n\n...\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.mdslepian","page":"Function index","title":"Multitaper.mdslepian","text":"mdslepian(w, k, t)\n\nGeneralized prolate spheroidal sequences for the 1D missing data problem\n\n...\n\nArguments\n\nPositional Arguments\n\nw::Float64: the bandwidth\nk::Int64: number of Slepian tapers, must be <=2bwlength(x) \nt::Vector{Int64}: vector containing the time indices\n\n...\n\n...\n\nOutputs\n\nlambda,u::Tuple{Vector{Float64}, Vector{Float64}}: tuple containing the \n\nconcentrations and the tapers\n\n...\n\nSee also: mdmultispec, gpss\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.gpss","page":"Function index","title":"Multitaper.gpss","text":"gpss(w, k, t, f; <keyword arguments>)\n\nGeneralized prolate spheroidal sequences on an unequal grid\n\n...\n\nArguments\n\nPositional Arguments\n\nw::Float64: the bandwidth\nk::Int64: number of Slepian tapers, must be <=2bwlength(x) \nt::Vector{Int64}: vector containing the time indices\nf::Float64: frequency at which the tapers are to be computed\n\nKeyword Arguments\n\nbeta::Float64 = 0.5: analysis half-bandwidth (similar to Nyquist rate)\n\n...\n\n...\n\nOutputs\n\nlambda::Vector{Float64} the concentrations of the generalized prolate spheroidal\n\nsequences\n\nu::Matrix{Float64} the matrix containing the sequences themselves\nR the Cholesky factor for the generalized eigenvalue problem\n\n...\n\nSee also: gpss_orth, mdmultispec, mdslepian\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper-Spectrum","page":"Function index","title":"Multitaper Spectrum","text":"","category":"section"},{"location":"lib/public/","page":"Function index","title":"Function index","text":"multispec\nmdmultispec\nwelch","category":"page"},{"location":"lib/public/#Multitaper.multispec","page":"Function index","title":"Multitaper.multispec","text":"multispec(S1; <keyword arguments>)\n\nComputes univariate multitaper spectra with a handful of extra gadgets. \n\n...\n\nArguments\n\nS1::Vector{T} where T<:Float64: the vector containing the time series\nNW::Float64 = 4.0: time-bandwidth product of estimate\nK::Int64 = 6: number of slepian tapers, must be <= 2*NW\ndt::Float64: sampling rate in time units \nctr::Bool: whether or not to remove the mean before computing the multitaper spectrum\npad::Float64 = 1.0: factor by which to pad the series, i.e. spectrum length will be pad times length of the time series.\ndpVec::Union{Matrix{Float64},Nothing} = nothing: Matrix of dpss's, if they have been precomputed\negval::Union{Vector{Float64},Nothing} = nothing: Vector of concentratins of said dpss's\nguts::Bool = false: whether or not to return the eigencoefficients in the output struct\na_weight::Bool = true: whether or not to use adaptive weighting\nFtest::Bool = true: Compute the F-test p-value\nhighres::Bool = false: Whether to return a \"high resolution\" spectrum estimate\njk::Bool = true: Compute jackknifed confidence intervals\nTsq::Union{Vector{Int64},Vector{Vector{Int64}},Nothing} = nothing: which frequency indices to compute the T-squared test for multiple line components. Defaults to none.\n\n...\n\n...\n\nOutputs\n\nMTSpectrum struct containing the spectrum\n\n...\n\nSee also: dpss_tapers, MTSpectrum, mdmultispec, mdslepian\n\n\n\n\n\nmultispec(S1, S2; <keyword arguments>)\n\nComputes multitaper cross-spectrum or coherence when given two time series with same sampling.\n\n...\n\nArguments\n\nS1::Union{Vector{T},EigenCoefficient} where T<:Number: the vector containing the first time\n\nseries\n\nS2::Union{Vector{P},EigenCoefficient} where P<:Number: the vector containing the second\n\ntime series\n\noutp::Symbol: output can be either :coh for coherence, :spec for cross-spectrum,\n\nor :transf for transfer function\n\nNW::Float64 = 4.0: time-bandwidth product of estimate\nK::Int64 = 6: number of slepian tapers, must be <= 2*NW\noffset::Union{Float64,Int64} = 0 set to nonzero value if offset coherence or\n\ncross-spectrum is desired. If Float64 is used, this will be converted to nearest FFT bin.\n\ndt::Float64: sampling rate in time units \nctr::Bool: whether or not to remove the mean before computing the multitaper\n\nspectrum\n\npad::Float64 = 1.0: factor by which to pad the series, i.e. spectrum length will\n\nbe pad times length of the time series.\n\ndpVec::Union{Matrix{Float64},Nothing} = nothing: Matrix of dpss's, if they have\n\nbeen precomputed\n\nguts::Bool = false: whether or not to return the eigencoefficients in the output\n\nstruct\n\njk::Bool = true: Compute jackknifed confidence intervals\nTsq::Union{Vector{Int64},Vector{Vector{Int64}},Nothing} = nothing: which\n\nfrequency indices to compute the T-squared test for multiple line components. Defaults to none.\n\nalph::Float64 = 0.05: significance cutoff for the Tsquared test\n\n...\n\n...\n\nOutputs\n\nMTSpectrum, MTCoherence, or MTTransferFunction struct containing the spectrum, coherence or\n\ntransfer function, depending on the selection of outp input. \n\n...\n\nSee also: dpss_tapers, MTSpectrum, mdmultispec, mdslepian\n\n\n\n\n\nmultispec(S1; <keyword arguments>)\n\nMultivariate version of the multispec call, data are in the columns of a matrix ...\n\nArguments\n\nS1::Matrix{T} where T<:Float64: the vector containing the first time series\noutp::Symbol: output can be either :coh for coherence, :justspeccs to compute just the spectra, or :cross for cross-spectra\nNW::Float64 = 4.0: time-bandwidth product of estimate\nK::Int64 = 6: number of slepian tapers, must be <= 2*NW\ndt::Float64: sampling rate in time units \nctr::Bool: whether or not to remove the mean before computing the multitaper spectrum\npad::Float64 = 1.0: factor by which to pad the series, i.e. spectrum length will be pad times length of the time series.\ndpVec::Union{Matrix{Float64},Nothing} = nothing: Matrix of dpss's, if they have been precomputed\nguts::Bool = false: whether or not to return the eigencoefficients in the output struct\na_weight::Bool = true: whether or not to adaptively weight the spectra\njk::Bool = false: Compute jackknifed confidence intervals\nFtest:Bool = false: Compute F-test for line components\nTsq::Union{Vector{Int64},Vector{Vector{Int64}},Nothing} = nothing: which frequency indices to compute the T-squared test for multiple line components. Defaults to none.\nalph::Float64 = 0.05: significance cutoff for the Tsquared test\n\n...\n\n...\n\nOutputs\n\nTuple{Vector{MTSpectrum},Vector{P},Union{Float64,Vector{Float64}}} where P = Union{MTCoherence,MTSpectrum} \n\nstruct containing the spectra, coherence or crossspectra, and Tsquared test p-values.  Ouput of middle arg depends on the selection of outp input.  ...\n\nSee also: dpss_tapers, MTSpectrum, mdmultispec, mdslepian\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.mdmultispec","page":"Function index","title":"Multitaper.mdmultispec","text":"mdmultispec(tt, x; <keyword arguments>)\n\nMultitaper power spectrum estimation for time series with missing data (gaps)\n\n...\n\nArguments\n\nPositional Arguments\n\ntt::Vector{T} where T<:Real: the vector containing the time indices\nx::Vector{P} where P<:Number: data vector\n\nKeyword Arguments\n\nbw = 5/length(tt): bandwidth of estimate\nk::Int64 = 2*bw*length(x)-1: number of Slepian tapers, must be `<=\n\n2bwlength(x)` \n\ndt::T = tt[2]-tt[1]: sampling rate in time units \nnz = 0.0: zero padding factor\nFtest::Bool = true: Compute the F-test p-value\njk::Bool = true: Compute jackknifed confidence intervals\ndof::Bool = false: Compute degrees of freedom for the adaptively weighted\n\nspectrum estimate\n\nlambdau::Union{Tuple{Array{Float64,1},Array{Float64,2}},Nothing} = nothing:\n\nSlepians, if precomputed ...\n\n...\n\nOutputs\n\npkg::MTSpectrum struct containing the spectrum\nnu1::Vector{Float64} optional vector containing the degrees of freedom, given\n\nif the dof kwarg is set to true.\n\n...\n\nSee also: multispec, mdslepian\n\n\n\n\n\nmdmultispec(tt, x, y; <keyword arguments>)\n\nMultitaper coherence estimation for time series with missing data (gaps)\n\n...\n\nArguments\n\nPositional Arguments\n\ntt::Vector{T} where T<:Real: the vector containing the time indices\nx::Vector{P} where P<:Number: data vector 1\ny::Vector{Q} where Q<:Number: data vector 2\n\nKeyword Arguments\n\nbw = 5/length(tt): bandwidth of estimate\nk::Int64 = 2*bw*length(x)-1: number of Slepian tapers, must be `<=\n\n2bwlength(x)`\n\ndt = tt[2]-tt[1]: sampling rate in time units \nnz = 0.0: zero padding factor\nFtest::Bool = true: Compute the F-test p-value\njk::Bool = true: Compute jackknifed confidence intervals\nlambdau::Union{Tuple{Array{Float64,1},Array{Float64,2}},Nothing} = nothing:\n\nSlepians, if precomputed\n\n...\n\n...\n\nOutputs\n\npkg::MTCoherence struct containing the coherence\n\n...\n\nSee also: multispec, mdslepian\n\n\n\n\n\nmdmultispec(tt, x; <keyword arguments>)\n\nMultitaper coherence estimation for multiple time series with the same missing data (gaps)\n\n...\n\nArguments\n\nKeyword Arguments\n\ntt::Vector{T} where T<:Real: the vector containing the time indices\nx::Matrix{P} where P<:Number: time series in the columns of a matrix\n\nPositional Arguments\n\nbw = 5/length(tt): bandwidth of estimate\nk::Int64 = 2*bw*length(x)-1: number of Slepian tapers, must be `<=\n\n2bwlength(x)` \n\ndt = tt[2]-tt[1]: sampling rate in time units \nnz = 0.0: zero padding factor\nFtest::Bool = false: Compute the F-test p-value\njk::Bool = true: Compute jackknifed confidence intervals\nlambdau::Union{Tuple{Array{Float64,1},Array{Float64,2}},Nothing} = nothing:\n\nSlepians, if precomputed\n\n...\n\n...\n\nOutputs\n\nTuple{Vector{MTSpectrum},Matrix{MTCoherence},Nothing} struct containing the spectra, \n\ncoherences, and T^2 test significances (currently set to return nothing)\n\n...\n\nSee also: multispec, mdslepian\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.welch","page":"Function index","title":"Multitaper.welch","text":"welch(S1, nsegments; <keyword arguments>)\n\nComputes univariate multitaper Welch specrum starting with an input time series.\n\n...\n\nArguments\n\nS1:Vector{T} where T<:Number: the vector containing the time series\nnsegments::Int64: the number of segments into which to divide the time series\noverlap::Float64 = 0.5: number between 0 and 1 which accounts for the amount of\n\noverlap between the segments\n\nNW::Float64 = 4.0: time-bandwidth product of estimate\nK::Int64 = 6: number of slepian tapers, must be <= 2*NW\ndt::Float64: sampling rate in time units\nctr::Bool: whether or not to remove the mean before computing the multitaper\n\nspectrum\n\npad::Float64 = 1.0: factor by which to pad the series, i.e. spectrum length will\n\nbe pad times length of the time series.\n\ndpVec::Union{Matrix{Float64},Nothing} = nothing: Matrix of dpss's, if they have\n\nbeen precomputed\n\negval::Union{Vector{Float64},Nothing} = nothing: Vector of concentratins of said\n\ndpss's\n\nguts::Bool = false: whether or not to return the eigencoefficients in the output\n\nstruct\n\na_weight::Bool = true: whether or not to use adaptive weighting\n\n...\n\n...\n\nOutputs\n\nMTSpectrum struct, depending on the selection of outp above\nFloat64 containing the effective bandwidth\n\n...\n\nSee also: multispec\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Time-domain-Statistics","page":"Function index","title":"Time-domain Statistics","text":"","category":"section"},{"location":"lib/public/","page":"Function index","title":"Function index","text":"mt_acf\nmt_acvf\nmt_ccvf\nmt_cepstrum\ndemodulate","category":"page"},{"location":"lib/public/#Multitaper.mt_acf","page":"Function index","title":"Multitaper.mt_acf","text":"mt_acf(S)\n\nComputes univariate multitaper autocorrelation function. Inputs a MTSpectrum struct.\n\n...\n\nArguments\n\nS::MTSpectrum: the vector containing the result of an univariate call to multispec\n\n...\n\n...\n\nOutputs\n\nMTAutocorrelationFunction struct containing the autocorrelation function\n\n...\n\nSee also: multispec\n\n\n\n\n\nmt_acf(S1; <keyword arguments>)\n\nComputes univariate multitaper autocorrelation function starting with an input time series. ...\n\nArguments\n\nS1::Vector{T} where T<:Number: the vector containing the time series\nNW::Float64 = 4.0: time-bandwidth product of estimate\nK::Int64 = 6: number of slepian tapers, must be <= 2*NW\ndt::Float64: sampling rate in time units \nctr::Bool: whether or not to remove the mean before computing the multitaper spectrum\npad::Float64 = 1.0: factor by which to pad the series, i.e. spectrum length will be pad times length of the time series.\ndpVec::Union{Matrix{Float64},Nothing} = nothing: Matrix of dpss's, if they have been precomputed\negval::Union{Vector{Float64},Nothing} = nothing: Vector of concentratins of said dpss's\na_weight::Bool = true: whether or not to use adaptive weighting\n\n...\n\n...\n\nOutputs\n\nMTAutocorrelationFunction struct containing the autocorrelation function\n\n...\n\nSee also: multispec\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.mt_acvf","page":"Function index","title":"Multitaper.mt_acvf","text":"mt_acvf(S)\n\nComputes univariate multitaper autocovariance function. Inputs a MTSpectrum struct.\n\n...\n\nArguments\n\nS::MTSpectrum: the vector containing the result of an univariate call to multispec\n\n...\n\n...\n\nOutputs\n\nMTAutocovarianceFunction struct containing the autocovariance function.\n\n...\n\nSee also: multispec\n\n\n\n\n\nmt_acvf(S1; <keyword arguments>)\n\nComputes univariate multitaper autocovariance function starting with an input time series. ...\n\nArguments\n\nS1::Vector{T} where T<:Number: the vector containing the time series\nNW::Float64 = 4.0: time-bandwidth product of estimate\nK::Int64 = 6: number of slepian tapers, must be <= 2*NW\ndt::Float64: sampling rate in time units \nctr::Bool: whether or not to remove the mean before computing the multitaper spectrum\npad::Float64 = 1.0: factor by which to pad the series, i.e. spectrum length will be pad times length of the time series.\ndpVec::Union{Matrix{Float64},Nothing} = nothing: Matrix of dpss's, if they have been precomputed\negval::Union{Vector{Float64},Nothing} = nothing: Vector of concentratins of said dpss's\na_weight::Bool = true: whether or not to use adaptive weighting\n\n...\n\n...\n\nOutputs\n\nMTAutocovarianceFunction struct containing the autocovariance function\n\n...\n\nSee also: multispec\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.mt_ccvf","page":"Function index","title":"Multitaper.mt_ccvf","text":"mt_ccvf(S; <keyword arguments>)\n\nComputes univariate multitaper cross-covariance/cross-correlation function. Inputs a MTSpectrum struct.\n\n...\n\nArguments\n\nS::MTSpectrum: the vector containing the result of an multiivariate call to multispec\ntyp::Symbol = :ccvf: whether to compute cross-correlation function (:ccf) or cross-covariance function (:ccvf)\n\n...\n\n...\n\nOutputs\n\nMtCrossCovarianceFunction, MTCrossCorrelationFunction depending on the selection of typ input above.\n\n...\n\nSee also: multispec\n\n\n\n\n\nmt_ccvf(S1, S2; <keyword arguments>)\n\nComputes bivariate multitaper cross-covariance/cross-correlation function from two time series\n\n...\n\nArguments\n\nS1::Vector{T} where T<:Number: the vector containing the first time series\nS2::Vector{T} where T<:Number: the vector containing the second time series\ntyp::Symbol: whether to compute cross-covariance function (:ccvf), or cross-correlation function (:ccf)\nNW::Float64 = 4.0: time-bandwidth product of estimate\nK::Int64 = 6: number of slepian tapers, must be <= 2*NW\ndt::Float64: sampling rate in time units \nctr::Bool: whether or not to remove the mean before computing the multitaper spectrum\npad::Float64 = 1.0: factor by which to pad the series, i.e. spectrum length will be pad times length of the time series.\ndpVec::Union{Matrix{Float64},Nothing} = nothing: Matrix of dpss's, if they have been precomputed\n\n...\n\n...\n\nOutputs\n\nMtCrossCovarianceFunction struct, depending on the selection of typ input above.\n\n...\n\nSee also: multispec\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.mt_cepstrum","page":"Function index","title":"Multitaper.mt_cepstrum","text":"mt_cepstrum(S)\n\nComputes multitaper cepstrum. Inputs a MTSpectrum struct.\n\n...\n\nArguments\n\nS::MTSpectrum: the vector containing the result of an univariate call to multispec\n\n...\n\n...\n\nOutputs\n\nMTCepstrum struct containing the cepstrum\n\n...\n\nSee also: multispec\n\n\n\n\n\nmt_cepstrum(S1; <keyword arguments>)\n\nComputes multitaper cepstrum starting with an input time series. ...\n\nArguments\n\nS1::Vector{T} where T<:Number: the vector containing the time series\nNW::Float64 = 4.0: time-bandwidth product of estimate\nK::Int64 = 6: number of slepian tapers, must be <= 2*NW\ndt::Float64: sampling rate in time units \nctr::Bool: whether or not to remove the mean before computing the multitaper spectrum\npad::Float64 = 1.0: factor by which to pad the series, i.e. spectrum length will be pad times length of the time series.\ndpVec::Union{Matrix{Float64},Nothing} = nothing: Matrix of dpss's, if they have been precomputed\negval::Union{Vector{Float64},Nothing} = nothing: Vector of concentratins of said dpss's\na_weight::Bool = true: whether or not to use adaptive weighting\n\n...\n\n...\n\nOutputs\n\nMTCepstrum struct containing the cepstrum\n\n...\n\nSee also: multispec\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.demodulate","page":"Function index","title":"Multitaper.demodulate","text":"demodulate(x, f0, NW, blockLen; <keyword arguments>)\n\nMultitaper complex demodulation\n\n...\n\nArguments\n\nx::Vector{T} where T<:Float64: the vector containing the time series\nf0::Float64: center frequency for the complex demodulate\nNW::Float64: the time bandwidth product\nblockLen::Int64: the length of the blocks to use \nwrapphase::Bool = true: whether or not to unwrap the phase\ndt::Float64 = 1.0: the sampling rate of the series, in time units\nbasetime::Float64 = 0.0: the time at which the time series begins\n\n...\n\n...\n\nOutputs\n\nA struct of type Demodulate\n\n...\n\nSee also: Demodulate, and relevant plots recipe demodplot\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Utilities","page":"Function index","title":"Utilities","text":"","category":"section"},{"location":"lib/public/","page":"Function index","title":"Function index","text":"tanhtrans\natanhtrans\nejn\nunwrapphase\nblockerr","category":"page"},{"location":"lib/public/#Multitaper.tanhtrans","page":"Function index","title":"Multitaper.tanhtrans","text":"tanhtrans(trcsq,ntf)\n\nInverse of the magnitude squared coherence variance stabilizing transform\n\n...\n\nArguments\n\ntrcsq::Float64: The transformed squared coherence\nntf::Int64: the number of tapers use to compute the coherence\n\n...\n\n...\n\nOutputs\n\nThe output is a Float64 indicating the reverse-transformed MSC\n\n...\n\nExample\n\nIf the transformed coherence is 7.3 and 6 dof, the significance is\n\njulia> invmscsig(tanhtrans(7.3,6),6)\n\nIf the significance is 0.9 and 6 dof the transformed msc is\n\njulia> atanhtrans(sqrt(mscsig(0.9,6)),6)\n\nSee also: multispec\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.atanhtrans","page":"Function index","title":"Multitaper.atanhtrans","text":"atanhtrans(c,ntf)\n\nMagnitude squared coherence variance stabilizing transform\n\n...\n\nArguments\n\nc::Float64: the value of the coherence\nntf::Int64: the number of tapers use to compute the coherence\n\n...\n\n...\n\nOutputs\n\nThe output is a Float64 indicating the transformed MSC\n\n...\n\nSee also: multispec\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.ejn","page":"Function index","title":"Multitaper.ejn","text":"ejn(DoF)\n\nExpected jackknife variance of an univariate multitaper spectrum estimate with DoF tapers\n\n...\n\nArguments\n\nDoF::Int64: the number of tapers use to compute the spectrum\n\n...\n\n...\n\nOutputs\n\nThe output is a Float64 indicating the expected jackknife variance.\n\n...\n\nSee also: multispec\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.unwrapphase","page":"Function index","title":"Multitaper.unwrapphase","text":"unwrapphase(y, typ)\n\nUnwrap the phase \n\n... \n\nArguments\n\ny::Vector{Float64}: The vector of phases\ntyp::Symbol: Whether to compute the unwrapped phase in degrees or radians\n\n...\n\n...\n\nOutputs\n\nx::Vector{Float64}: The vector of unwrapped phases\n\n...\n\n\n\n\n\nAlternative phase unwrapper which takes a complex argument. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.blockerr","page":"Function index","title":"Multitaper.blockerr","text":"blockerr(lengt, nsegmentts; <keyword arguments>)\n\nBlocker code to divide the data into segments \n\n...\n\nArguments\n\nlengt::Int64: input length of a time series\nnsegments::Int64: number of segments\noverlap::Float64 = 0.0: fraction of overlap between segments, between 0.0 and 1.0\n\n...\n\n...\n\nOutputs\n\nseq::Vector{Int64}: Beginning index for each segment\nseg_len::Int64: length of the segments\nov::Float64: overlap that actually resulted (≈overlap, above)\n\n...\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Number-of-Crossings","page":"Function index","title":"Number of Crossings","text":"","category":"section"},{"location":"lib/public/","page":"Function index","title":"Function index","text":"Pgram_upcrossings\nMT_Upcrossings\nuctable","category":"page"},{"location":"lib/public/#Multitaper.Pgram_upcrossings","page":"Function index","title":"Multitaper.Pgram_upcrossings","text":"Pgram_upcrossings(z, N)\n\nNumber of upcrossings of the level z of a periodogram spectrum per Rayleigh resolution ...\n\nArguments\n\nz::Float64: the level of the standardized spectrum\nN::Int64: sampling rate in time units \n\n...\n\n...\n\nOutputs\n\nFloat64: the number of upcrossings per Rayleigh\n\n...\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.MT_Upcrossings","page":"Function index","title":"Multitaper.MT_Upcrossings","text":"MT_Upcrossings(z, α, CR, N)\n\nNumber of upcrossings of the level z of a multitaper spectrum per Rayleigh resolution ...\n\nArguments\n\nz::Float64: the level of the standardized spectrum\nα::Float64: degrees of freedom of estimate\n`CR::Float64: time bandwidth product\nN::Int64: sampling rate in time units \n\n...\n\n...\n\nOutputs\n\nFloat64: the number of upcrossings per Rayleigh\n\n...\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Multitaper.uctable","page":"Function index","title":"Multitaper.uctable","text":"Gives an upcrossing table for α = K, CR = NW (Float), optionally num_Ray has default 1e5, and signficiance levels that can be chosen, or set to default \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Two-Dimensional-Spectrum","page":"Function index","title":"Two Dimensional Spectrum","text":"","category":"section"},{"location":"lib/public/","page":"Function index","title":"Function index","text":"rectsleps\nmultispec2_Rectangle","category":"page"},{"location":"lib/public/#Under-development","page":"Function index","title":"Under development","text":"","category":"section"},{"location":"lib/public/#Slepians-with-gaps","page":"Function index","title":"Slepians with gaps","text":"","category":"section"},{"location":"lib/public/","page":"Function index","title":"Function index","text":"MDSlepian","category":"page"},{"location":"lib/public/#Unequal-sampling","page":"Function index","title":"Unequal sampling","text":"","category":"section"},{"location":"lib/public/","page":"Function index","title":"Function index","text":"gpss\nbspec","category":"page"},{"location":"lib/public/#Multitaper.bspec","page":"Function index","title":"Multitaper.bspec","text":"bspec(times, dat, W, K, beta, nz, Ftest)\n\nComputes the Bronez spectrum of an unequally-spaced time series\n\n...\n\nPositional Arguments\n\ntimes::Vector{T} where T<: Number: the vector containing the times\ndat::Vector{T} where T<:Number: the vector containing the time series \nW::Float64: bandwidth of estimate\nK::Int64: number of slepian tapers, must be <= 2*NW\nbeta::Float64: estimated process bandwidth (aka Nyquist rate)\nnz::Union{Float64,Int64} = length(t): Number of frequencies\nFtest::Bool = false: Whether to compute the F-test or not\n\n...\n\n...\n\nOutputs\n\nMTSpectrum struct containing the Bronez spectrum\n\n...\n\n...\n\nExample usage\n\nN = 256\nt = collect(1:N).^(1.05)\nW = 0.008\nK = 5\nx = randn(N)\nbet = 0.5 / (last(t) / (N-1))\nM = 2*N\nS = bspec(t, x, W, K, bet, nz, true)\n\n...\n\nSee also: multispec, mdmultispec, mdslepian, gpss\n\n\n\n\n\nbspec(time, dat1, dat2, W, K, bet, nz; <keyword arguments>)\n\nComputes the Bronez coherence or cross-spectrum of two unequally-spaced time series\n\n...\n\nPositional Arguments\n\ntime::Vector{T} where T<:Number: the vector containing the times \ndat1::Union{Vector{P}, EigenCoefficient} where P<:Number: the vector containing the first time series \ndat2::Union{Vector{P}, EigenCoefficient} where P<:Number: the vector containing the second time series\nW::Float64: bandwidth of estimate\nK::Int64: number of slepian tapers, must be <= 2*NW\nbet::Float64: Nyquist frequency\nnz::Union{Float64,Int64} = length(t): Number of frequencies\n\nKeyword Arguments\n\noutp::Symb = :coh: Output, either :cross for cross spectrum or :coh (default)\nparams::Union{MTParameters,Nothing} = nothing: parameters struct, important when x,y are EigenCoefficients\nFtest::Bool = false: Whether to compute the F-test or not\n\n...\n\n...\n\nOutputs\n\nMTCoherence containing the Bronez coherence\n\n...\n\n...\n\nExample usage\n\nN = 256\nt = collect(1:N).^(1.05)\nW = 0.008\nK = 5\nx = randn(N)\ny = randn(N) # Incoherent\nM = 2*N\nbeta = 0.5\nS = bspec(t, x, y, W, K, M, beta)\n\n...\n\nSee also: multispec, mdmultispec, mdslepian, gpss\n\n\n\n\n\nbspec(time, dat, W, K, bet, nz; <keyword arguments>)\n\nComputes the Bronez spectra and coherences of p unequally-spaced time series\n\n...\n\nPositional Arguments\n\ntime::Vector{T} where T<:Number: the vector containing the times \ndat::Matrix{Vector{P}} where T<:Number: the matrix containing the time series in its columns\nW::Float64: bandwidth of estimate\nK::Int64: number of slepian tapers, must be <= 2*NW\nbet::Float64: Nyquist frequency\nnz::Union{Float64,Int64} = length(t): Number of frequencies\n\nKeyword Arguments\n\noutp::Symb = :coh: Output, either :cross for cross spectrum or :coh (default)\nFtest::Bool = false: Whether to compute the F-test or not\n\n...\n\n...\n\nOutputs\n\ntuple(Vector{MTSpectrum},Matrix{MTCoherence},Nothing) containing the Bronez spectra and coherences\n\n...\n\n...\n\nExample usage\n\nN = 256\nt = collect(1:N).^(1.05)\nW = 0.008\nK = 5\nx = randn(N)\ny = randn(N) # Incoherent\nM = 2*N\nbeta = 0.5\nS = bspec(t, hcat(x, y), W, K, beta, M, outp = :coh, Ftest = true)\n\n...\n\nSee also: multispec, mdmultispec, mdslepian, gpss\n\n\n\n\n\n","category":"function"},{"location":"k_univariate/#Univariate-Functions","page":"Univariate Functions","title":"Univariate Functions","text":"","category":"section"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The univariate functionality of this package computes multitaper estimates of the power spectrum, autocorrelation, cepstrum, and complex demodulation of a time series. One can also estimate the power spectrum when there is missing data.  ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"An estimate of the power spectral density contains information about the sample variance of the time series, decomposed in terms of frequency. When the multitaper method is used, multiple tapering functions ensure that the statistical bias-variance tradeoff is optimized.  Discrete prolate spheroidal sequences, which are used as tapering functions, are finite-length sequences whose Fourier transforms contain most of their power on a narrow bandwidth. This property makes them optimal for reducing spectral leakage. The orthogonality of the tapering functions also means that one can compute empirical confidence intervals for the spectrum estimate by jackknifing, and estimate the significance of discrete sinusoids using an F-test.  Finally, one can compute the quantities above when time series are sampled on a regular grid for which there are missing data points. ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"Cepstrum analysis is widely used in speech processing applications and for deconvolution. Complex demodulation of a time series allows for examination of the amplitude and phase of a sinusoid at a frequency of interest to the time series being studied. ","category":"page"},{"location":"k_univariate/#Quick-Synopsis-of-Capabilities","page":"Univariate Functions","title":"Quick Synopsis of Capabilities","text":"","category":"section"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"Univariate","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"Discrete Prolate Spheroidal sequences\nMultitaper spectra that use dpss (multispec) tapers\nJackknifing","category":"page"},{"location":"k_univariate/#Univariate-spectrum-estimation","page":"Univariate Functions","title":"Univariate spectrum estimation","text":"","category":"section"},{"location":"k_univariate/#multispec","page":"Univariate Functions","title":"multispec","text":"","category":"section"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"multispec(S1)","category":"page"},{"location":"k_univariate/#Multitaper.multispec-Tuple{Any}","page":"Univariate Functions","title":"Multitaper.multispec","text":"multispec(S1; <keyword arguments>)\n\nComputes univariate multitaper spectra with a handful of extra gadgets. \n\n...\n\nArguments\n\nS1::Vector{T} where T<:Float64: the vector containing the time series\nNW::Float64 = 4.0: time-bandwidth product of estimate\nK::Int64 = 6: number of slepian tapers, must be <= 2*NW\ndt::Float64: sampling rate in time units \nctr::Bool: whether or not to remove the mean before computing the multitaper spectrum\npad::Float64 = 1.0: factor by which to pad the series, i.e. spectrum length will be pad times length of the time series.\ndpVec::Union{Matrix{Float64},Nothing} = nothing: Matrix of dpss's, if they have been precomputed\negval::Union{Vector{Float64},Nothing} = nothing: Vector of concentratins of said dpss's\nguts::Bool = false: whether or not to return the eigencoefficients in the output struct\na_weight::Bool = true: whether or not to use adaptive weighting\nFtest::Bool = true: Compute the F-test p-value\nhighres::Bool = false: Whether to return a \"high resolution\" spectrum estimate\njk::Bool = true: Compute jackknifed confidence intervals\nTsq::Union{Vector{Int64},Vector{Vector{Int64}},Nothing} = nothing: which frequency indices to compute the T-squared test for multiple line components. Defaults to none.\n\n...\n\n...\n\nOutputs\n\nMTSpectrum struct containing the spectrum\n\n...\n\nSee also: dpss_tapers, MTSpectrum, mdmultispec, mdslepian\n\n\n\n\n\nmultispec(S1; <keyword arguments>)\n\nMultivariate version of the multispec call, data are in the columns of a matrix ...\n\nArguments\n\nS1::Matrix{T} where T<:Float64: the vector containing the first time series\noutp::Symbol: output can be either :coh for coherence, :justspeccs to compute just the spectra, or :cross for cross-spectra\nNW::Float64 = 4.0: time-bandwidth product of estimate\nK::Int64 = 6: number of slepian tapers, must be <= 2*NW\ndt::Float64: sampling rate in time units \nctr::Bool: whether or not to remove the mean before computing the multitaper spectrum\npad::Float64 = 1.0: factor by which to pad the series, i.e. spectrum length will be pad times length of the time series.\ndpVec::Union{Matrix{Float64},Nothing} = nothing: Matrix of dpss's, if they have been precomputed\nguts::Bool = false: whether or not to return the eigencoefficients in the output struct\na_weight::Bool = true: whether or not to adaptively weight the spectra\njk::Bool = false: Compute jackknifed confidence intervals\nFtest:Bool = false: Compute F-test for line components\nTsq::Union{Vector{Int64},Vector{Vector{Int64}},Nothing} = nothing: which frequency indices to compute the T-squared test for multiple line components. Defaults to none.\nalph::Float64 = 0.05: significance cutoff for the Tsquared test\n\n...\n\n...\n\nOutputs\n\nTuple{Vector{MTSpectrum},Vector{P},Union{Float64,Vector{Float64}}} where P = Union{MTCoherence,MTSpectrum} \n\nstruct containing the spectra, coherence or crossspectra, and Tsquared test p-values.  Ouput of middle arg depends on the selection of outp input.  ...\n\nSee also: dpss_tapers, MTSpectrum, mdmultispec, mdslepian\n\n\n\n\n\n","category":"method"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"This command does a lot of the univariate stuff. Its signature is:","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"function multispec(S1::Union{Vector{T}}; \n                   NW::Real = 4.0, \n                   K::Int = 6, \n                   dt::Float64 = 1.0, \n                   ctr::Bool = true, \n                   pad::Union{Int,Float64} = 1.0, \n                   dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing,\n                   egval::Union{Vector{Float64},Nothing} = nothing,\n                   guts::Bool = false, \n                   a_weight::Bool = true, \n                   Ftest::Bool = false, \n                   highres::Bool = false,\n                   jk::Bool = false, \n                   Tsq::Union{Vector{Float64},Vector{Vector{Float64}},\n                      Vector{Int64},Vector{Vector{Int64}},Nothing} = nothing, \n                   alph::Float64 = 0.05\n                  ) where T<:Number","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"S1 is the time series, and you have the following keyword options:","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"NW, the choice of time-bandwidth product\nK, the number of tapers to use\ndt, the temporal sampling frequency (in, say, seconds)\nctr, whether or not to remove the mean from the data series, default is true\npad, the padded length will be pad times the length of S1.  \ndpVec, you can choose to supply the dpss's or not (speeds things up if you're calling the function many times)\negval, eigenvalues associated with the vectors above, optional\nguts, whether you'd like the eigencoefficients as output. They will come in an eigencoefficient struct with the field coef, wts where coef contains the eigencoefficients and wts will contain the adaptive weights\na_weight, whether to use the adaptive weighting scheme described in Thomson, 1982\nFtest, whether to compute the harmonic F-test described in Thomson, 1982\nhighres, whether the estimate should be a high-resolution estimate, see Thomson 1982\njk, jackknifing to give a confidence interval for the spectrum\nTsq, T-squared test for multiple line components (Thomson Asilomar conference proceedings)\nalph, confidence level for jackknife confidence intervals and Tsq tests.","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The output of this command is a MTSpectrum struct which contains the following fields (in the following order):","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"frequency (f), as a LinRange\nspectrum (S), a vector giving half the spectrum up to the Nyquist if the input is real\nphase (optional), \nchosen values of the multitaper time bandwidth product etc of type MTParameters (params) This makes its own parameter struct that contains NW, K, N, dt, M (padded","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"length), nsegments (number of segments of data to averae), overlap (if the sample was   divided into overlapping chunks) and it gets carried around for future reference and   for plotting purposes","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"eigencoefficients (coef, optional), \nFtest values (Fpval, optional), \njackknife output (jkvar, optional), and\nTsquared test results (Tsq_pval, optional). ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"Some of the fields will contain nothing, or if you requested one of the jacknifed confidence interval (jk = true), F-test for line components (Ftest = true), multivariate T^2 test for line components (Tsq != nothing), or the eigencoefficients and possibly adaptive weights (guts=true), then the relevant fields in the output struct will be filled. ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"Note that pad here can be given in two different ways: if it is a float, then it is the factor by which to multiply the length of the original data sequence, and if it is an integer larger than the length of the original data sequence, it will be the number of data points in the full FFT.","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"If dpVec is given, you have supplied pre-computed Slepians, which will speed things up if the function is going to be called many times.  The option a_weight uses adaptive weighting. ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"A note on plotting: if you are using Plots.jl there are pre-loaded recipes that make plotting of MTSpectrum structs completely trivial. Simply plot your MTSpectrum structs as if they were vectors, and you'll get a bunch of preformatting for free. Consult the jupyter notebooks for examples of some of the recipes.","category":"page"},{"location":"k_univariate/#Welch","page":"Univariate Functions","title":"Welch","text":"","category":"section"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The welch estimate of the spectrum is one that is an average of multitaper spectra computed on overlapping data blocks. You'd call the function like this","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"welch(S1::Union{Vector{Float64}, Vector{ComplexF64}, Matrix{Float64}, \n               Matrix{ComplexF64}}, \n               nsegments::Int64, overlap::Float64 = 0.5, ws::Symbol = :welch; \n               outp::Symbol = :spec,\n               NW::Real = 4.0, K::Int = 6, dt::Float64 = 1.0,\n               ctr::Bool = true, pad::Union{Int,Float64} = 1.0,\n               dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing, \n               egval::Union{Vector{Float64},Nothing} = nothing, \n               guts::Bool = false, a_weight::Bool = true, Ftest::Bool = false, \n               jk::Bool = false, \n               Tsq::Union{Array{Int64,1},Array{Array{Int64,1},1},Nothing}=nothing,\n               alph::Float64 = 0.05) ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The call is very similar to the multispec call above, except you will enter the parameters nsegments and overlap, that is, the number of data blocks to make, and the overlap between them. Since there is some fudging these numbers, you will get the number of segments and overlap back in the params field of the output struct. The ws toggle is by default set to :welch mode, but this code is also the backbone for a spectrogram, which is why this keyword argument is here. ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"Note that this function returns a tuple: the first argument is a MTSpectrum object, and the second is the effective bandwidth (See Thomson and Chave 1991).","category":"page"},{"location":"k_univariate/#Time-domain-statistics","page":"Univariate Functions","title":"Time domain statistics","text":"","category":"section"},{"location":"k_univariate/#mt_acvf","page":"Univariate Functions","title":"mt_acvf","text":"","category":"section"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"This function computes multitaper estimates of the covariance, correlation, and cepstrum, by way of inverse-FFT of a multitaper spectrum estimate. Its signature is either","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"function mt_acvf(S::MTSpectrum)","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"or","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"function mt_acvf(S1::Union{Vector{T}}; \n                 NW::Real = 4.0, \n                 K::Int = 6, \n                 dt::Float64=1.0, \n                 ctr::Bool = true, \n                 pad::Union{Int,Float64} = 1.0, \n                 dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing,\n                 egval::Union{Vector{Float64},Nothing} = nothing,\n                 a_weight::Bool = true, \n                 reshape::Union{Bool, Float64, Int64, Vector{Float64}, \n                          Vector{Int64}} = false,\n                 ) where T<:Number","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The first method is used if you've already computed the spectrum and have the MTSpectrum struct handy.  If not, you can use the second version, putting in the time series, and using any other relevant input arguments mentioned in the multispec call above.","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The output is","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"MTAutocorrelationFunction: Contains lags, autocorrelation function, and a params struct (mentioned above) that carries around the relevant multitaper options. ","category":"page"},{"location":"k_univariate/#mt_acf","page":"Univariate Functions","title":"mt_acf","text":"","category":"section"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"This function computes multitaper estimates of the correlation by way of inverse-FFT of a multitaper spectrum estimate. Its signature is either","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"function mt_acf(S::MTSpectrum)","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"or","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"function mt_acf(S1::Union{Vector{T}}; \n                 NW::Real = 4.0, \n                 K::Int = 6, \n                 dt::Float64=1.0, \n                 ctr::Bool = true, \n                 pad::Union{Int,Float64} = 1.0, \n                 dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing,\n                 egval::Union{Vector{Float64},Nothing} = nothing,\n                 a_weight::Bool = true, \n                 reshape::Union{Bool, Float64, Int64, Vector{Float64}, \n                          Vector{Int64}} = false,\n                 ) where T<:Number","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The first method is used if you've already computed the spectrum and have the MTSpectrum struct handy.  If not, you can use the second version, putting in the time series, and using any other relevant input arguments mentioned in the multispec call above.","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The output is","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"MTAutocovarianceFunction: Contains lags, autocovariance function, and a params struct.","category":"page"},{"location":"k_univariate/#mt_cepstrum","page":"Univariate Functions","title":"mt_cepstrum","text":"","category":"section"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"This function computes multitaper estimate of the cepstrum, by way of inverse-FFT of the logarithm of a multitaper spectrum estimate. Its signature is either","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"function mt_cepstrum(S::MTSpectrum)","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"or","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"function mt_cepstrum(S1::Union{Vector{T}}; \n                 NW::Real = 4.0, \n                 K::Int = 6, \n                 dt::Float64=1.0, \n                 ctr::Bool = true, \n                 pad::Union{Int,Float64} = 1.0, \n                 dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing,\n                 egval::Union{Vector{Float64},Nothing} = nothing,\n                 a_weight::Bool = true, \n                 reshape::Union{Bool, Float64, Int64, Vector{Float64}, \n                          Vector{Int64}} = false,\n                 ) where T<:Number","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The first method is used if you've already computed the spectrum and have the MTSpectrum struct handy.  If not, you can use the second version, putting in the time series, and using any other relevant input arguments mentioned in the multispec call above.","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The output is","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"MTCepstrum: Contains lags (quefrency), a cepstrum estimate, and a params struct. The cepstrum is the inverse-FFT (or cosine transform, when the signal is real) of the","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"logarithm of the spectrum. ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"When you plot one of the MTAutocorrelationFunction, MTAutocovarianceFunction, or MTCepstrum structs using the recipe, you'll get a stem plot. ","category":"page"},{"location":"k_univariate/#demodulate","page":"Univariate Functions","title":"demodulate","text":"","category":"section"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"This function computes the multitaper estimate of the complex demodulate. Note that there are several published implementations of this, but this one uses a single zeroth order Slepian taper as a filter. Note that this is identical to the implementation in the R multitaper package. The function signature is ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"function demodulate(x::Vector{Float64}, f0::Float64, NW::Float64, blockLen::Int64, \n                    wrapphase::Bool = true, dt::Float64, basetime::Float64)","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The inputs are the following:","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"x is the data vector to be demodulated\ndt is the sampling rate (in years, for example)\nf0 is the center frequency (e.g. one cycle per year)\nNW is the time-bandwidth product for the filter (typically narrow, use a float)\nblockLen is a subjective length to use for the data filter, note that the output  will be shortened by this amount, so a short filter is sometimes better. \nwrapphase is an optional boolean which tells the algorithm whether or not to  unwrap the phase for pretty plotting. \nbasetime is the time for the first time index","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The output will be a Demodulate struct containing time (time), magnitude (mag), and phase (phase).  For easy plotting there is a Plots.jl recipe. See also the notebook 04_Demodulation.ipynb in the Examples directory for usage.  ","category":"page"},{"location":"k_univariate/#Missing-data-Spectrum","page":"Univariate Functions","title":"Missing-data Spectrum","text":"","category":"section"},{"location":"k_univariate/#mdmultispec","page":"Univariate Functions","title":"mdmultispec","text":"","category":"section"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"Chave showed how to compute dpss's and multitaper spectra on data with gaps (Chave,2019). The function signature is ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"function mdmultispec(tt::Union{Vector{Int64},Vector{Float64}}, x::Vector{Float64}; \n                bw=5/length(tt), k=Int64(2*bw*size(x,1)-1), \n                lambdau::Union{Tuple{Array{Float64,1},\n                               Array{Float64,2}},Nothing} = nothing,\n                dt=tt[2]-tt[1], nz=0, Ftest=true, jk=true,\n                dof=false)","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The inputs are the following:","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"tt – real vector of time (required)\nx – real vector of data (required)\nbw – bandwidth of estimate, 5/length(t) default\nk – number of slepian tapers, must be <=2 bw length(x), 2 bw length(x)-1 default\nlambdau – missing data Slepian tapers and their concentrations, if precomputed\ndt – sampling in time\nnz – zero padding factor, 0 default\nFtest – whether or not to compute the F-test p-value at all frequencies\njk – whether or not to compute jackknife variance estimates\ndof – whether or not to output the degrees of freedom of the estimate","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The outputs are simply a list of the following ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"sxx – MTSpectrum spectrum \nnu1 – Degrees of freedom, if dof is set to true","category":"page"},{"location":"k_univariate/#mdslepian","page":"Univariate Functions","title":"mdslepian","text":"","category":"section"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"One can also simply generate Slepian tapers for the missing data problem using the mdslepian function. Its function signature is ","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"function mdslepian(w, k, t)","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The inputs are the following:","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"w – the bandwidth of the taper\nk – the number of Slepian tapers\nt – the vector containing the time indicees","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The outputs are","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"lambda – the concentrations of the missing-data Slepians\nu – length(t) times k matrix containing the missing-data Slepians","category":"page"},{"location":"k_univariate/#gpss","page":"Univariate Functions","title":"gpss","text":"","category":"section"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"Following the work of  (Bronez, 1988, one can compute optimally concentrated data tapers on a general, uneven, temporal grid. These are called generalized prolate spheroidal sequences. The function with the following signature computes these","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"function gpss(w::Float64, k::Int64, t::Union{Vector{Int64},Vector{Float64}}, \n        f::Float64; beta::Float64 = 0.5)","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The inputs are the following:","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"w – the bandwidth of the taper\nk – the number of Slepian tapers\nt – the vector containing the time indicees\nf – the frequency of interest, between 0 and beta\nbeta – the unequal sampling equivalent to the Nyquist rate","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"The outputs are","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"lambda – the concentrations of the missing-data Slepians\nu – length(t) times k matrix containing the missing-data Slepians\nR – Cholesky factor for the generalized eigenvalue problem","category":"page"},{"location":"k_univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"!!! This function is known to occasionally have numerical errors in computing the Cholesky factors of the genealized eigenvalue problem, so use at own risk. For the cases we tested, however, this function generally returns the expected result.","category":"page"},{"location":"n_examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"n_examples/","page":"Examples","title":"Examples","text":"There are a number of IJulia.jl noteboooks in the Examples directory. The simplest way to run these may be to first instantiate the project folder in Examples using","category":"page"},{"location":"n_examples/","page":"Examples","title":"Examples","text":"(v1.0) pkg> activate .\n(Examples) pkg> instantiate\n>julia include(\"run_notebooks.jl\")","category":"page"},{"location":"n_examples/","page":"Examples","title":"Examples","text":"This will open a browser window containing the notebooks, where you can run them.","category":"page"},{"location":"j_manual/#User-manual","page":"User manual","title":"User manual","text":"","category":"section"},{"location":"j_manual/#Why-Multitaper?","page":"User manual","title":"Why Multitaper?","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The multitaper method is a  widely used set of methods for nonparametric estimation of frequency domain  quantities relevant to time series such as the power spectrum, coherence, and transfer function. For an accessible introduction to multitaper methods, we recommend (Park, Lindberg, and Vernon, 1987).","category":"page"},{"location":"j_manual/#Structs","page":"User manual","title":"Structs","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"Multitaper.jl outputs spectra, coherences, transfer functions, etc. in the form of Julia structs. The main reason for this is in the ease of Plotting.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The basic frequency domain structs are","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"MTSpectrum\nMTCoherence \nMTTransferFunction","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"where MT signifies that these are multitaper estimates. Under the hood, one will find the above structs may contain the following ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"EigenCoefficient\nMTParameters.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"Finally, one may be interested in computing the following time domain quantities","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"Demodulate\nMTAutocorrelationFunction \nMTAutocovarianceFunction\nMTCepstrum\nMtCrossCovarianceFunction \nMTCrossCorrelationFunction.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"Below we expand on these basic structs.","category":"page"},{"location":"j_manual/#MTSpectrum","page":"User manual","title":"MTSpectrum","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTSpectrum struct contains a multitaper spectrum estimate which consists of  the following fields:","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"f is the range of frequencies\nS contains the spectrum estimate\nphase contains the vector of phases, if this is a cross-spectrum, and otherwise nothing.\nparams is a MTParameters struct which stores the choice of bandwidth and other quantities for the multitaper.\ncoef is a EigenCoefficient struct which stores the intermediate values of the calculation, if desired. These may be useful for subsequent calculations.\nFpval is the vector of F-test p-values at every frequency, see  ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"(Thomson, 1982).","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"jkvar is the vector of jackknifed variance estimates at every frequency.\nTsq_pval contains the result of a T^2 test for multiple lines, if requested. This field otherwise contains nothing. ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTSpectrum struct is generated by the function multispec when called on a time series","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"using Multitaper, Plots\nx = rand(100); # A time series consisting of 100 random points\nS = multispec(x); # Compute the multitaper spectrum of the data using NW = 4\ntypeof(S)\nplot(S)","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"There is a plots recipe, see Plotting, for plotting structs of this type. ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"There is an IJulia.jl notebook in  Multitaper.jl/Examples/01_basic_multitaper.ipynb  showing an example taken from the excellent text  (Percival and Walden, 1993). To run this notebook on a cloned copy of the repo, follow the instructions in  Examples. ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The multispec function, when run on a single time series, additionally allows one  to compute the following quantities:","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"F-test p-value, by setting the kwarg Fpval = true. This tests for a spectral line at every frequency. \nT-squared test p-value (Thomson, 2011)","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"An example of the former are available in the Multitaper.jl/Examples/01_basic_multitaper.ipynb notebook. ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The main advantage of the multitaper spectrum is that one can simultaneously control the bias and variance of the estimator by varying the time-bandwidth product, NW. This parameter is used to compute the multiple orthogonal tapers, see dpss_tapers, on which the method depends. When one computes the multitaper spectrum, this parameter, along with a number of other quantities is given in the output in the form of a MTParameters struct. ","category":"page"},{"location":"j_manual/#MTParameters","page":"User manual","title":"MTParameters","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"This struct holds the following quantities","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"NW which is the chosen time-bandwidth product of the estimator. See (Haley and Anitescu, 2017) for some ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"comments on optimal choice of NW. ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"K which is the number of tapers. One typically chooses K = 2NW as the eigenvalue problem that gives the tapers has only 2NW large eigenvalues. For details on discrete prolate spheroidal sequences, which are used as data tapers, consult dpss_tapers and  (Slepian, 1978). \nN which is the number of data points in the time series.\ndt is the sampling interval, typically in seconds. \nM is the length of the output spectrum, usually different from N because of zero-padding.\nnsegments is the number of data blocks that have been made from the time series. When one calls multispec, nsegments is one, but if one has called welch, one can control the number of segments using the keyword argument of the same name.\noverlap is the proportion of data by which the segments overlap, which is set to nothing if there is only one segment, but by default is 0.5 if one uses the welch method. ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"These quantities are important when plotting, as they give indicators of the resolution of the estimate, as indicated by a small cross-shape in the plotted spectrum. See notebooks in Examples and Plotting for details.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"Finally, if one selects the value true for the keyword argument guts, then the intermediate values of the multitaper calculation are returned as well. These intermediate values are eigencoefficients.","category":"page"},{"location":"j_manual/#EigenCoefficient","page":"User manual","title":"EigenCoefficient","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The struct containing eigencoefficients has two fields ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"coef the complex-valued tapered Fourier transformed data, and\nwts which are the result of an adaptive weighting calculation, which are only computed if a_weight is set to true in a call to multispec. ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"(See (Thomson, 1982) for   the optional adaptive weighting procedure).","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"For details of the additional keyword arguments relevant to multispec, see multispec entry in index.","category":"page"},{"location":"j_manual/#MTCoherence","page":"User manual","title":"MTCoherence","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTCoherence struct contains a multitaper spectrum estimate which consists of  the following fields:","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"f is the range of frequencies\ncoh contains the coherence estimate, in transformed units, i.e. transformed by the function atanhtransf. One can convert back to original squared coherence using the tanhtrans function. \nphase contains the vector of phases. Phase is by default unwrapped, which allows values outside of [-180,180) degrees.\nparams is a MTParameters struct which stores the choice of bandwidth and other quantities for the multitaper.\ncoef is a EigenCoefficient struct which stores the intermediate values of the calculation, if desired. These may be useful for subsequent calculations.\njkvar is the vector of jackknifed variance estimates at every frequency.\nTsq_pval contains the result of a T^2 test for multiple lines, if requested. This field otherwise contains nothing. ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTCoherence struct is generated by the function multispec when called on two time series with the default output option.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"There is a plots recipe, see Plotting, for plotting structs of this type. ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"There is an IJulia.jl notebook in  Multitaper.jl/Examples/02_multivariate.ipynb  showing an example taken from the excellent (and freely available) text  (Shumway and Stoffer). To run this notebook on a cloned copy of the repo, follow the instructions in  Examples. ","category":"page"},{"location":"j_manual/#MTTransf","page":"User manual","title":"MTTransf","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTTransf struct contains a multitaper transfer function estimate (Thomson and  Chave, 1991) which consists of the following fields:","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"f is the range of frequencies\ntransf contains the transfer function estimate, in transformed units, i.e. transformed by the function atanhtransf. One can convert back to original squared coherence using the tanhtrans function. \nphase contains the vector of phases. Phase is by default unwrapped, which allows values outside of [-180,180) degrees.\nparams is a MTParameters struct which stores the choice of bandwidth and other quantities for the multitaper.\ncoef is a EigenCoefficient struct which stores the intermediate values of the calculation, if desired. These may be useful for subsequent calculations.\njkvar is the vector of jackknifed variance estimates at every frequency.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTTransf struct is generated by the function multispec when called on two time series with the output option set to :transf.","category":"page"},{"location":"j_manual/#Time-Domain-Structs","page":"User manual","title":"Time Domain Structs","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"Finally, we come to the time domain structs, which are indexed by lag.","category":"page"},{"location":"j_manual/#Demodulate","page":"User manual","title":"Demodulate","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The Demodulate struct contains a multitaper complex demodulate estimate which consists of the following fields:","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"time is the range of times over which the time series is collected.\nmag contains the vector of magnitudes of the complex demodulate.\nphase contains the vector of phases. Phase is by default unwrapped, which allows values outside of [-180,180) degrees.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The Demodulate struct is generated by the function demodulate when called on the time series.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"There is a plots recipe, see Plotting, for plotting structs of this type. ","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"There is an IJulia.jl notebook in  Multitaper.jl/Examples/04_Demodulation.ipynb  showing an example taken from the paper (Thomson, 1995)  and R multitaper. To run this notebook on a cloned copy of the repo, follow the instructions in  Examples. The authors acknowledge the work of K. Rahim and W. Burr, authors of the aforementioned R package, for the function template and example in docs.","category":"page"},{"location":"j_manual/#MTAutocorrelationFunction","page":"User manual","title":"MTAutocorrelationFunction","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTAutocorrelationFunction struct contains a multitaper estimate of autocorrelation which consists of the following fields:","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"lags is the range of times over which the time series is collected.\nacf contains the vector of autocorrelations computed on the time series.\nparams contains the MTParameters struct containing the multitaper bandwidth and other parameters","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTAutocorrelationFunction struct is generated by the function mt_acf when called on the time series.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"There is a plots recipe, see Plotting, for plotting structs of this type. ","category":"page"},{"location":"j_manual/#MTAutocovarianceFunction","page":"User manual","title":"MTAutocovarianceFunction","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTAutocovarianceFunction struct contains a multitaper estimate of autocovariance which consists of the following fields:","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"lags is the range of times over which the time series is collected.\nacvf contains the vector of autocovariances computed on the time series.\nparams contains the MTParameters struct containing the multitaper bandwidth and other parameters","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTAutocorrelationFunction struct is generated by the function mt_acvf when called on the time series.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"There is a plots recipe, see Plotting, for plotting structs of this type. ","category":"page"},{"location":"j_manual/#MTCepstrum","page":"User manual","title":"MTCepstrum","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTCepstrum struct contains a multitaper cepstrum estimate which consists of the following fields:","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"time is the range of times over which the time series is collected.\nceps contains the vector of cepstrum coefficients.\nphase contains the vector of phases. Phase is by default unwrapped, which allows values outside of [-180,180) degrees.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTCepstrum struct is generated by the function mt_cepstrum when called on the time series.","category":"page"},{"location":"j_manual/#MtCrossCovarianceFunction","page":"User manual","title":"MtCrossCovarianceFunction","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTCrossCovarianceFunction struct contains a multitaper estimate of  cross covariance which consists of the following fields:","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"lags is the range of times over which the time series is collected.\nccvf contains the vector of cross covariances computed on the two time series.\nparams contains the MTParameters struct containing the multitaper bandwidth and other parameters","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTCrossCovarianceFunction struct is generated by the function mt_ccvf when called on the two time series.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"There is a plots recipe, see Plotting, for plotting structs of this type. ","category":"page"},{"location":"j_manual/#MTCrossCorrelationFunction","page":"User manual","title":"MTCrossCorrelationFunction","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTCrossCorrelationFunction struct contains a multitaper estimate of  cross correlation which consists of the following fields:","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"lags is the range of times over which the time series is collected.\nccf contains the vector of cross correlations computed on the two time series.\nparams contains the MTParameters struct containing the multitaper bandwidth and other parameters","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"The MTCrossCorrelationFunction struct is generated by the function mt_ccvf when called on the two time series.","category":"page"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"There is a plots recipe, see Plotting, for plotting structs of this type. ","category":"page"},{"location":"j_manual/#Functions-creating-the-structs","page":"User manual","title":"Functions creating the structs","text":"","category":"section"},{"location":"j_manual/","page":"User manual","title":"User manual","text":"Now that the basic structs have been defined, we can begin to describe the functions that create them. See Function index for all of these. ","category":"page"},{"location":"#Multitaper.jl-Documentation","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"","category":"section"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"Documentation for Multitaper.jl","category":"page"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"A package for multitaper frequency-domain analysis.","category":"page"},{"location":"#Package-Features","page":"Multitaper.jl Documentation","title":"Package Features","text":"","category":"section"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"When doing exploratory analysis of time series, frequency domain methods, that is, statistical methods that display information about the temporal correlations of one or more time series in terms of frequencies, can be used to infer physical mechanisms for underlying process dynamics in e.g. geophysical time series, medical time series, etc.). The multitaper method, which leverages Slepian functions to estimate power spectral densities, coherences, and so forth, is implemented here for application to univariate, multivariate, and higher-dimensional (e.g. space-time) processes.","category":"page"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"Multitaper.jl is a Julia package for spectrum analysis of time series, multivariate time series, and spatial or space-time processes. Multitaper.jl was designed to be useful to researchers in diverse fields, including geophysics (climate, seismology, limnology, and stratigraphy), cognitive radio, space science (solar physics), speech processing, astronomy, and biomedicine. For example, a researcher might want to compute the multitaper spectrum of a time series so he or she can identify which periodic components contribute the most to signal variance, and do so with jackknifed error bounds on the oscillation amplitudes. ","category":"page"},{"location":"#Univariate-time-series","page":"Multitaper.jl Documentation","title":"Univariate time series","text":"","category":"section"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"Discrete Prolate Spheroidal sequences (Slepian 1974) and with gaps (Chave 2019) \nMultitaper spectra that use dpss (multispec) tapers, where time series can have gaps. \nJackknifing for estimation of the confidence intervals.\nF-test for line components (Thomson, 1982).\nComplex demodulation\nMultitaper spectrum estimation for time series with equal temporal spacing except with gaps (Chave 2019)","category":"page"},{"location":"#Multivariate-time-series","page":"Multitaper.jl Documentation","title":"Multivariate time series","text":"","category":"section"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"Magnitude squared coherence, implemented in the spirit of Thomson and Chave, 1991.\nJackknife estimates of phase, unwrapped, similar to R's implementation. \nT-squared test (Thomson, \"Some comments on possibly cyclostationary series\", Asilomar Conference Proceedings) for simultaneous line components. ","category":"page"},{"location":"#Dimensional","page":"Multitaper.jl Documentation","title":"2 Dimensional","text":"","category":"section"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"2 Dimensional Cartesian tapers supported on the square in space and 2D disk in time as described in Simons and Wang, 2011 ","category":"page"},{"location":"#Plots-Recipes","page":"Multitaper.jl Documentation","title":"Plots Recipes","text":"","category":"section"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"Plots recipes are provided for numerous function ouputs. ","category":"page"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"The Examples provides tutorial IJulia.jl notebooks showing how to get  started using Multitaper.","category":"page"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#Installation","page":"Multitaper.jl Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"This package is unregistered, so please install with","category":"page"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"Pkg> add https://github.com/lootie/Multitaper.jl.git","category":"page"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"This package runs on Julia v 1.4.2 and above. ","category":"page"},{"location":"#Testing","page":"Multitaper.jl Documentation","title":"Testing","text":"","category":"section"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"In order to test this package, use","category":"page"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"Pkg> test Multitaper","category":"page"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"This will run the tests in test/runtests.jl.","category":"page"},{"location":"#Manual","page":"Multitaper.jl Documentation","title":"Manual","text":"","category":"section"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"","category":"page"},{"location":"#main-index","page":"Multitaper.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"Multitaper.jl Documentation","title":"Multitaper.jl Documentation","text":"Pages = [\"lib/public.md\"]","category":"page"},{"location":"l_multivariate/#Multivariate-Functions","page":"Multivariate Functions","title":"Multivariate Functions","text":"","category":"section"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"The multivariate capabilities of this package include cross-spectrum and coherence analysis, which contain information about the covariance properties (respectively, correlations) between two time series. As in the univariate case, multiple tapers are used to de-bias the estimates, and this results in individual estimates that can be used to get a jackknifed confidence interval for either quantity of interest. Trivially, one can obtain multitaper estimates for the cross-covariance and cross-correlation functions by inverse Fourier transforming the multitaper cross-spectrum and coherence. ","category":"page"},{"location":"l_multivariate/#Quick-Synopsis-of-Capabilities","page":"Multivariate Functions","title":"Quick Synopsis of Capabilities","text":"","category":"section"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"Multivariate","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"Magnitude squared coherence  \nJackknife estimates of phase","category":"page"},{"location":"l_multivariate/#Multivariate-spectrum-estimation","page":"Multivariate Functions","title":"Multivariate spectrum estimation","text":"","category":"section"},{"location":"l_multivariate/#multispec","page":"Multivariate Functions","title":"multispec","text":"","category":"section"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"The multispec command does a lot of the multivariate stuff as well. You will recognize most of the keyword arguments from the univariate version of this call. However, there are a few differences now. You can either use the first, simpler version, of the multivariate call: ","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"function multispec(S1::Union{Vector{T},EigenCoefficient}, S2::Union{Vector{T},EigenCoefficient}; \n                   outp=:coh, NW=4.0, K=6, offset=0, dt=1.0, ctr=true, pad=1.0,\n                   dpVec=nothing, guts=false, jk=false, Tsq=nothing, alph=0.05) where{T}","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"In which","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"S1 is now the first input time series, and S2 is the second, OR, S1 and S2 can be","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"eigencoefficient structs from a previous computation (for speed if you are calling these functions often) ","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"outp is the desired output of the computation which now can be :spec for","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"cross-spectrum, :coh for coherence and phase, or :transf for transfer function.","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"NW, the choice of time-bandwidth product\nK, the number of tapers to use\noffset, the frequency offset, if desired (else 0.0)\ndt, the temporal sampling frequency (in, say, seconds)\nctr, whether or not to remove the mean from the data series, default is true\npad, the padded length will be pad times the length of S1.  \ndpVec, you can choose to supply the dpss's or not (speeds things up if you're calling the function many times)\nguts, whether you'd like the eigencoefficients as output. They will come in an eigencoefficient struct with the field coef, wts where coef contains the eigencoefficients and wts will contain the adaptive weights\njk, jackknifing to give a confidence interval for the spectrum\nTsq, T-squared test for multiple line components (Thomson Asilomar conference proceedings)\nalph, confidence level for jackknife confidence intervals and Tsq tests.","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"The output struct you get will be determined by what outp is, namely one of ","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"MTSpectrum struct which will contain the following fields (in","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"the following order):","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"frequency (f), as a LinRange\ncross-spectrum (S), a vector giving half the spectrum up to the Nyquist if the input is real\nphase, \nchosen values of the multitaper time bandwidth product etc of type MTParameters (params) This makes its own parameter struct that contains NW, K, N, dt, M (padded","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"length), nsegments (number of segments of data to averae), overlap (if the sample was   divided into overlapping chunks) and it gets carried around for future reference and   for plotting purposes","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"eigencoefficients (coef, optional), \nFtest values (Fpval, optional), \njackknife output (jkvar, optional), and\nTsquared test results (Tsq_pval, optional).This struct was described","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"earlier, in this case the phase output field will be filled in.","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"MTCoherence coherence struct. Its fields are \nfrequency (f)\ncoh, a vector giving the squared coherence up to the Nyquist if the input is real\nphase, \nchosen values of the multitaper time bandwidth product etc of type MTParameters (params) This makes its own parameter struct that contains NW, K, N, dt, M (padded length), nsegments (number of segments of data to averae), overlap (if the sample  was divided into overlapping chunks) and it gets carried around for future reference  and for plotting purposes\neigencoefficients (coef, optional), \njackknife output (jkvar, optional), and\nTsquared test results (Tsq_pval, optional). \nMTTransferFunction transfer function struct. Its fields are\nfrequency (f)\ntransf, a vector giving the transfer function up to the Nyquist if the input is real\nphase, \nchosen values of the multitaper time bandwidth product etc of type MTParameters (params) This makes its own parameter struct that contains NW, K, N, dt, M (padded","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"length), nsegments (number of segments of data to averae), overlap (if the sample was divided into overlapping chunks) and it gets carried around for future reference and for plotting purposes","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"eigencoefficients (coef, optional), \njackknife output (jkvar, optional), and\nTsquared test results (Tsq_pval, optional). ","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"Now, you can also use the batch-version of this call: ","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"function multispec(S1::Matrix{T}; outp=:coh, NW=4.0, K=6, dt=1.0, ctr=true,\n                   pad=1.0, dpVec=nothing, guts=false, a_weight=true, jk=false,\n                   Ftest=false, Tsq=nothing, alph=0.05) where{T}","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"S1 is now just a matrix with, say, p columns and N rows, meaning that there are p","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"input time series. ","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"outp is the desired output of the computation which now can be :cross for","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"cross-spectrum, :coh for coherence and phase, or :justspecs for only the   spectra.","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"NW, the choice of time-bandwidth product\nK, the number of tapers to use\noffset, the frequency offset, if desired (else 0.0)\ndt, the temporal sampling frequency (in, say, seconds)\nctr, whether or not to remove the mean from the data series, default is true\npad, the padded length will be pad times the length of S1.  \ndpVec, you can choose to supply the dpss's or not (speeds things up if you're calling the function many times)\nguts, whether you'd like the eigencoefficients as output. They will come in an eigencoefficient struct with the field coef, wts where coef contains the eigencoefficients and wts will contain the adaptive weights\njk, jackknifing to give a confidence interval for the spectrum\nTsq, T-squared test for multiple line components (Thomson Asilomar conference proceedings)\nalph, confidence level for jackknife confidence intervals and Tsq tests.","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"The output of this command, depending on the desired output type, is one of three things:","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"outp = :justspecs is a vector of MTSpectrum structs containing the spectra alone. \noutp = :coh is a tuple containing the spectra, a matrix filled with coherences on the super-diagonal (so if the result was called out, you'd access it by using","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"out[2][1,2] to get the coherence between the first and second series.), and finally the result of the T-squared test, if you asked for it. ","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"outp = :cross is a tuple containing the spectra, a matrix filled with cross spectra on the super-diagonal, and finally the result of the T-squared test, if you","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"asked for it. ","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"A note on plotting: if you are using Plots.jl there recipes to directly plot the output of the above multivariate calculations, especially the tuples, in a gridded plot format. See the second jupyter notebook for more details. ","category":"page"},{"location":"l_multivariate/#Missing-data-coherences","page":"Multivariate Functions","title":"Missing-data coherences","text":"","category":"section"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"Extending the missing-data spectrum estimation of  (Chave, 2019)  from the univariate case to the bivariate case, one can compute coherences using the function with signature","category":"page"},{"location":"l_multivariate/#mdmultispec","page":"Multivariate Functions","title":"mdmultispec","text":"","category":"section"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"function mdmultispec(t::Union{Vector{Int64}, Vector{Float64}}, \n                x::Vector{Float64},\n                y::Vector{Float64};\n                bw::Float64 = 5/length(t),\n                k::Int64    = Int64(2*bw*size(x,1) - 1),\n                dt::Float64 = 1.0, jk::Bool = true,\n                nz::Union{Int64,Float64}   = 0, \n                Ftest::Bool = false,\n                lambdau::Union{Tuple{Array{Float64,1},\n                               Array{Float64,2}},Nothing} = nothing)","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"The inputs are the following:","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"t – real vector of time\nx – first missing-data time series\ny – second missing-data time series\nbw – bandwidth of estimate, 5/length(t) default\nk – number of slepian tapers, must be <=2 bw length(x), 2 bw length(x)-1 default\ndt – sampling in time\njk – whether or not to compute jackknife variance estimates\nnz – zero padding factor, 0 default\nFtest – whether or not to compute the F-test p-value at all frequencies\nlambdau – missing data Slepian tapers and their concentrations, if precomputed","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"The output is ","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"sxx – MTCoherence coherence estimate ","category":"page"},{"location":"l_multivariate/#Time-domain-statistics","page":"Multivariate Functions","title":"Time domain statistics","text":"","category":"section"},{"location":"l_multivariate/#mt_ccvf","page":"Multivariate Functions","title":"mt_ccvf","text":"","category":"section"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"This function computes multitaper estimates of the cross-covariance and cross-correlation by way of inverse-FFT of a multitaper spectrum estimate. Its signature is either","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"function mt_ccvf(S::MTSpectrum; typ::Symbol = :ccvf)","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"or","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"mt_ccvf(S1::Vector{T}, S2::Vector{T}; typ::Symbol = :ccvf, NW::Real = 4.0, K::Int = 6, \n                   dt::Float64=1.0, ctr::Bool = true, \n                   pad::Union{Int,Float64} = 1.0, \n                   dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing,\n                   guts::Bool = false, \n                   jk::Bool = false, \n                   Tsq::Union{Vector{Float64},Vector{Vector{Float64}},Vector{Int64},\n                   Vector{Vector{Int64}},Nothing}=nothing, \n                   alph::Float64 = 0.05) where T<:Number","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"In the first, we assume that you have the MTSpectrum struct handy (must be cross-spectra, coherences won't work), and in the second you give the two time series, similar to above.  The typ kwarg can take values in (:ccvf and :ccf) with :ccvf being the default value. Depending on the value of typ, you will get one of two different structs","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"MTCrossCorrelationFunction: Contains lags, cross correlation function, and a MTParameters  struct that carries around the relevant multitaper options. \nMtCrossCovarianceFunction: Contains lags, cross covariance function, and a MTParameters struct.","category":"page"},{"location":"l_multivariate/","page":"Multivariate Functions","title":"Multivariate Functions","text":"when you plot one of the MTCrossCorrelationFunction or MtCrossCovarianceFunction structs using the recipe, you'll get a stem plot. ","category":"page"},{"location":"m_plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"For those using Plots.jl, we use RecipesBase.jl to quickly plot the output structs given by the base functions. ","category":"page"},{"location":"m_plotting/#Quick-synopsis-of-recipes","page":"Plotting","title":"Quick synopsis of recipes","text":"","category":"section"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"One can plot univariate structs","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"MTSpectrum structs, which are outputs of the multispec function. These are ordinary power spectrum estimates.\nMTAutocorrelationFunction, Mtacvf structs, which are outputs of the mtacf and mtacvf function. These are autocorrelation or autocovariance estimates, respectively. \nMTCepstrum structs, which are multitaper cepstra.\nDemodulate structs, which contain complex demodulates.","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"And multivariate structs","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"MTCoherence structs, which are outputs of the multivariate multispec function. These are coherence estimates. \nOutputs of coherence calculations are often given as Tuple{Array{MTSpectrum{C,T,P,1},Array{MTCoherence,2},Nothing}, and the corresponding recipe","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"will plot all of the spectra, coherences, and phases on a grid. ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"MtCrossCovarianceFunction and Mtccf structs, which are outputs of the mtccvf and mtccf ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"functions, respectively. These are plots of the multitaper cross-covariance function or cross-correlation function.","category":"page"},{"location":"m_plotting/#Univariate-recipes","page":"Plotting","title":"Univariate recipes","text":"","category":"section"},{"location":"m_plotting/#Plotting-spectra","page":"Plotting","title":"Plotting spectra","text":"","category":"section"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"To plot a univariate spectrum estimate, use the recipe with signature","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"@recipe function plot(S::MTSpectrum; cross = true)","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The following arguments are necessary","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"MTSpectrum struct is the output of a call to multispec where only a single time series has been given, or two time series were given and the output desired is a  cross-spectrum.","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"With the vanilla call to the plot recipe, one will get the power spectrum plotted on a logarithmic base 10 scale in the y-axis and appropriately labeled axes. If the jackknifed variance field (jkvar) in the MTSpectrum struct contains values, then 95 percent confidence intervals will be shown as shaded bands around the spectrum. If the phase field contains values, then the y-axis will say \"Cross-Spectrum\" instead of \"Spectrum\".  ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The optional keyword argument specifies","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"cross shows a small cross-shaped mark in the corner of the plot having width twice the bandwidth, and height equal to the expected jackknifed variance. ","category":"page"},{"location":"m_plotting/#Plotting-autocorrelations","page":"Plotting","title":"Plotting autocorrelations","text":"","category":"section"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"To plot a multitaper estimate of autocorrelation, use the recipe with signature","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"@recipe function acfplt(A::MTAutocorrelationFunction)","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The following arguments are necessary","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"MTAutocorrelationFunction struct is the output of a call to mtacf with a single time series given. ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The resulting plot will be a stem plot labeled as lags on the x-axis and autocorrelations on the y-axis. ","category":"page"},{"location":"m_plotting/#Plotting-autocovariances","page":"Plotting","title":"Plotting autocovariances","text":"","category":"section"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"To plot a multitaper estimate of autocovariance, use the recipe with signature","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"@recipe function acvfplt(A::MTAutocovarianceFunction)","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The following arguments are necessary","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"MTAutocovarianceFunction struct is the output of a call to mt_acvf with a single time series given. ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The resulting plot will be a stem plot labeled as lags on the x-axis and autocovariances on the y-axis. ","category":"page"},{"location":"m_plotting/#Cepstrum-plot","page":"Plotting","title":"Cepstrum plot","text":"","category":"section"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"To plot the cepstrum, use the recipe with signature ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"@recipe function cepsplt(A::MTCepstrum)","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The following arguments are necessary","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"MTCepstrum which is the output of a mt_ceps function call.","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The resulting plot will show the cepstrum coefficient as a stem plot in terms of lags. ","category":"page"},{"location":"m_plotting/#Demodulate-plot","page":"Plotting","title":"Demodulate plot","text":"","category":"section"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"To plot the complex demodulate, use the recipe with signature ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"@recipe function demodplt(cdm::Demodulate)","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The following arguments are necessary","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"cdm which is the output of a Demodulate function call.","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The resulting plot will show the complex demoodulate in two stacked panels, one for the magnitude and one for the phase of the complex quantity. ","category":"page"},{"location":"m_plotting/#Multivariate-recipes","page":"Plotting","title":"Multivariate recipes","text":"","category":"section"},{"location":"m_plotting/#Coherence-plotting","page":"Plotting","title":"Coherence plotting","text":"","category":"section"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"To plot a multitaper estimate of the coherence, use","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"@recipe function plot(C::MTCoherence; phase = false, sigMax = 0)","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The following arguments are necessary","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"MTCoherence which is the output of a multispec call with more than one time series as input and coherence as output. ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The resulting plot shows the magnitude squared coherences on a scale from 0 to 1, if no jackknifing has been done. If jackknifing has been done, the magnitude squared coherence is shown on a transformed scale (inverse hyperbolic tangent) and 95 percent confidence intervals will be shown as a shaded band. ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The following keyword arguments can be set","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"phase when set to true produces a second subplot below the first which shows the (unwrapped) values of the phase estimate.\nsigMax is the number of significance lines to put on the plot. These lines are at (1.0 - 10^{1:sigMax}). For example, if one selects the default, namely sigMax = 4,","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"one obtains lines at 0.9, 0.99, 0.999, 0.9999. ","category":"page"},{"location":"m_plotting/#Comparing-coherences","page":"Plotting","title":"Comparing coherences","text":"","category":"section"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"To plot multiple estimates of the coherence together on the same axes for comparison,  use","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"@recipe function plot(C::Matrix{MTCoherence}; phase = false, jk = false, sigMax = 0)","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The following arguments are necessary","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"MTCoherence is as above.","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The following keyword arguments can be set","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"phase and sigMax are as above.\njk plots confidence intervals when set to true.","category":"page"},{"location":"m_plotting/#Coherences-and-spectra","page":"Plotting","title":"Coherences and spectra","text":"","category":"section"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"To plot the coherences and spectra from, say, a call to multispec where there are two or more time series, one uses the recipe with the following signature:","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"@recipe function\nspecCohMatrix(Spec::Tuple{Array{MTSpectrum{C,T,P},1},Array{MTCoherence,2},Nothing}; \n                                sigMax = 0) where C where T where P","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"One obtains a plot with ptimes p panels (if p is the number of time series) where spectra are shown in red on the diagonals, MSC are on the upper triagonal panels of the plot, and phases are on the lower triagonal panels of the plot. ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The required input is ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"Spec which is of type Tuple{Array{MTSpectrum{C,T,P},1},Array{MTCoherence,2},Nothing}; which is the result one gets when one calls multispec on two or more time series. ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The keywork argument","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"sigMax is as above.","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"!!! Note that at the time of this writing, it was impossible to not require Plots.jl as a dependency when using an advanced layoout, so some bonus plotting routines are in Multitaper.jl/src/PlotsRecipes/Coherence_Plot.jl. This code can be included on the fly for an even more advanced layout. The layout one gets has three axes, one is the transformed MSC, one is the MSC in units from 0 to 1, and the third axes is the significance if the true MSC were zero. ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The main function in this piece of code has the following signature:","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"@recipe function f(h::MTCoherence; siglines = true, msclines = true, sigMax = 4, legtext = false, \n        force_ylims = nothing, mscaxis = true, sigaxis = true, jk = true)","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The MTCoherence type input is explanatory (it is as above), but one has the additional keyword arguments as follows","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"siglines allows one to put a selected number of horizontal lines on the plot (specifically, sigMax number of lines are added)  indicating the significance of a magnitude squared coherence value under the null","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"hypothesis that the two series have zero coherence at that frequency. ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"msclines allows one to put horizontal lines at various levels of the msc\nsigMax is the number of significance lines to put on the plot. These lines are at (1.0 - 10^{1:sigMax}). For example, if one selects the default, namely sigMax = 4,","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"one obtains lines at 0.9, 0.99, 0.999, 0.9999. ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"legtext puts text in the legend.\nforce_ylims gives the y-limits for the transformed axis, if desired. \nmscaxis when toggled to false will delete the MSC axis on the scale from 0 to 1. \nsigaxis when toggled to false will delete the significance axis.\njk indicates whether jackknife confidence intervals will be drawn. ","category":"page"},{"location":"m_plotting/#Cross-covariance-and-Cross-correlation-plots","page":"Plotting","title":"Cross-covariance and Cross-correlation plots","text":"","category":"section"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"The following two recipe signatures:","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"@recipe function ccvfplot(A::MtCrossCovarianceFunction)","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"and ","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"@recipe function ccfplot(A::MTCrossCorrelationFunction)","category":"page"},{"location":"m_plotting/","page":"Plotting","title":"Plotting","text":"will show either the cross-covariance estimate (if the input is of type MtCrossCovarianceFunction) or the cross-correlation estimate (if the input is of type MTCrossCorrelationFunction) as a stem plot.","category":"page"}]
}
