<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multivariate Functions · Multitaper</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Multitaper</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Multitaper.jl Documentation</a></li><li><a class="tocitem" href="../j_manual/">User manual</a></li><li><a class="tocitem" href="../k_univariate/">Univariate Functions</a></li><li class="is-active"><a class="tocitem" href>Multivariate Functions</a><ul class="internal"><li><a class="tocitem" href="#Quick-Synopsis-of-Capabilities"><span>Quick Synopsis of Capabilities</span></a></li><li><a class="tocitem" href="#Multivariate-spectrum-estimation"><span>Multivariate spectrum estimation</span></a></li><li><a class="tocitem" href="#Missing-data-coherences"><span>Missing-data coherences</span></a></li><li><a class="tocitem" href="#Time-domain-statistics"><span>Time domain statistics</span></a></li></ul></li><li><a class="tocitem" href="../lib/public/">Function index</a></li><li><a class="tocitem" href="../m_plotting/">Plotting</a></li><li><a class="tocitem" href="../n_examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Multivariate Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multivariate Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lootie/multitaper.jl/src/master/docs/src/l_multivariate.md#lines-" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Multivariate-Functions"><a class="docs-heading-anchor" href="#Multivariate-Functions">Multivariate Functions</a><a id="Multivariate-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-Functions" title="Permalink"></a></h1><p>The multivariate capabilities of this package include cross-spectrum and coherence analysis, which contain information about the covariance properties (respectively, correlations) between two time series. As in the univariate case, multiple tapers are used to de-bias the estimates, and this results in individual estimates that can be used to get a jackknifed confidence interval for either quantity of interest. Trivially, one can obtain multitaper estimates for the cross-covariance and cross-correlation functions by inverse Fourier transforming the multitaper cross-spectrum and coherence. </p><h2 id="Quick-Synopsis-of-Capabilities"><a class="docs-heading-anchor" href="#Quick-Synopsis-of-Capabilities">Quick Synopsis of Capabilities</a><a id="Quick-Synopsis-of-Capabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Synopsis-of-Capabilities" title="Permalink"></a></h2><p>Multivariate</p><ul><li><p>Magnitude squared coherence  </p></li><li><p>Jackknife estimates of phase</p></li></ul><h2 id="Multivariate-spectrum-estimation"><a class="docs-heading-anchor" href="#Multivariate-spectrum-estimation">Multivariate spectrum estimation</a><a id="Multivariate-spectrum-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-spectrum-estimation" title="Permalink"></a></h2><h3 id="multispec"><a class="docs-heading-anchor" href="#multispec">multispec</a><a id="multispec-1"></a><a class="docs-heading-anchor-permalink" href="#multispec" title="Permalink"></a></h3><p>The multispec command does a lot of the multivariate stuff as well. You will recognize most of the keyword arguments from the univariate version of this call. However, there are a few differences now. You can either use the first, simpler version, of the multivariate call: </p><pre><code class="nohighlight">function multispec(S1::Union{Vector{T},EigenCoefficient}, S2::Union{Vector{T},EigenCoefficient}; 
                   outp=:coh, NW=4.0, K=6, offset=0, dt=1.0, ctr=true, pad=1.0,
                   dpVec=nothing, guts=false, jk=false, Tsq=nothing, alph=0.05) where{T}</code></pre><p>In which</p><ul><li><code>S1</code> is now the first input time series, and S2 is the second, OR, S1 and S2 can be</li></ul><p>eigencoefficient structs from a previous computation (for speed if you are calling these functions often) </p><ul><li><code>outp</code> is the desired output of the computation which now can be <code>:spec</code> for</li></ul><p>cross-spectrum, <code>:coh</code> for coherence and phase, or <code>:transf</code> for transfer function.</p><ul><li><code>NW</code>, the choice of time-bandwidth product</li><li><code>K</code>, the number of tapers to use</li><li><code>offset</code>, the frequency offset, if desired (else 0.0)</li><li><code>dt</code>, the temporal sampling frequency (in, say, seconds)</li><li><code>ctr</code>, whether or not to remove the mean from the data series, default is true</li><li><code>pad</code>, the padded length will be pad times the length of S1.  </li><li><code>dpVec</code>, you can choose to supply the dpss&#39;s or not (speeds things up if you&#39;re calling the function many times)</li><li><code>guts</code>, whether you&#39;d like the eigencoefficients as output. They will come in an eigencoefficient struct with the field coef, wts where coef contains the eigencoefficients and wts will contain the adaptive weights</li><li><code>jk</code>, jackknifing to give a confidence interval for the spectrum</li><li><code>Tsq</code>, T-squared test for multiple line components (Thomson Asilomar conference proceedings)</li><li><code>alph</code>, confidence level for jackknife confidence intervals and Tsq tests.</li></ul><p>The output struct you get will be determined by what <code>outp</code> is, namely one of </p><ul><li><code>MTSpectrum</code> struct which will contain the following fields (in</li></ul><p>the following order):</p><ul><li>frequency (f), as a LinRange</li><li>cross-spectrum (S), a vector giving half the spectrum up to the Nyquist if the input is real</li><li>phase, </li><li>chosen values of the multitaper time bandwidth product etc of type <code>MTParameters</code> (params) This makes its own parameter struct that contains NW, K, N, dt, M (padded</li></ul><p>length), nsegments (number of segments of data to averae), overlap (if the sample was   divided into overlapping chunks) and it gets carried around for future reference and   for plotting purposes</p><ul><li>eigencoefficients (coef, optional), </li><li>Ftest values (Fpval, optional), </li><li>jackknife output (jkvar, optional), and</li><li>Tsquared test results (Tsq_pval, optional).This struct was described</li></ul><p>earlier, in this case the <code>phase</code> output field will be filled in.</p><ul><li><p><code>MTCoherence</code> coherence struct. Its fields are </p></li><li><p>frequency (f)</p></li><li><p>coh, a vector giving the squared coherence up to the Nyquist if the input is real</p></li><li><p>phase, </p></li><li><p>chosen values of the multitaper time bandwidth product etc of type <code>MTParameters</code> (params) This makes its own parameter struct that contains NW, K, N, dt, M (padded length), nsegments (number of segments of data to averae), overlap (if the sample  was divided into overlapping chunks) and it gets carried around for future reference  and for plotting purposes</p></li><li><p>eigencoefficients (coef, optional), </p></li><li><p>jackknife output (jkvar, optional), and</p></li><li><p>Tsquared test results (Tsq_pval, optional). </p></li><li><p><code>MTTransferFunction</code> transfer function struct. Its fields are</p></li><li><p>frequency (f)</p></li><li><p>transf, a vector giving the transfer function up to the Nyquist if the input is real</p></li><li><p>phase, </p></li><li><p>chosen values of the multitaper time bandwidth product etc of type <code>MTParameters</code> (params) This makes its own parameter struct that contains NW, K, N, dt, M (padded</p></li></ul><p>length), nsegments (number of segments of data to averae), overlap (if the sample was divided into overlapping chunks) and it gets carried around for future reference and for plotting purposes</p><ul><li>eigencoefficients (coef, optional), </li><li>jackknife output (jkvar, optional), and</li><li>Tsquared test results (Tsq_pval, optional). </li></ul><p>Now, you can also use the batch-version of this call: </p><pre><code class="nohighlight">function multispec(S1::Matrix{T}; outp=:coh, NW=4.0, K=6, dt=1.0, ctr=true,
                   pad=1.0, dpVec=nothing, guts=false, a_weight=true, jk=false,
                   Ftest=false, Tsq=nothing, alph=0.05) where{T}</code></pre><ul><li><code>S1</code> is now just a matrix with, say, p columns and N rows, meaning that there are p</li></ul><p>input time series. </p><ul><li><code>outp</code> is the desired output of the computation which now can be <code>:cross</code> for</li></ul><p>cross-spectrum, <code>:coh</code> for coherence and phase, or <code>:justspecs</code> for only the   spectra.</p><ul><li><code>NW</code>, the choice of time-bandwidth product</li><li><code>K</code>, the number of tapers to use</li><li><code>offset</code>, the frequency offset, if desired (else 0.0)</li><li><code>dt</code>, the temporal sampling frequency (in, say, seconds)</li><li><code>ctr</code>, whether or not to remove the mean from the data series, default is true</li><li><code>pad</code>, the padded length will be pad times the length of S1.  </li><li><code>dpVec</code>, you can choose to supply the dpss&#39;s or not (speeds things up if you&#39;re calling the function many times)</li><li><code>guts</code>, whether you&#39;d like the eigencoefficients as output. They will come in an eigencoefficient struct with the field coef, wts where coef contains the eigencoefficients and wts will contain the adaptive weights</li><li><code>jk</code>, jackknifing to give a confidence interval for the spectrum</li><li><code>Tsq</code>, T-squared test for multiple line components (Thomson Asilomar conference proceedings)</li><li><code>alph</code>, confidence level for jackknife confidence intervals and Tsq tests.</li></ul><p>The output of this command, depending on the desired output type, is one of three things:</p><ul><li><p><code>outp = :justspecs</code> is a vector of MTSpectrum structs containing the spectra alone. </p></li><li><p><code>outp = :coh</code> is a tuple containing the spectra, a matrix filled with coherences on the super-diagonal (so if the result was called out, you&#39;d access it by using</p></li></ul><p><code>out[2][1,2]</code> to get the coherence between the first and second series.), and finally the result of the T-squared test, if you asked for it. </p><ul><li><code>outp = :cross</code> is a tuple containing the spectra, a matrix filled with cross spectra on the super-diagonal, and finally the result of the T-squared test, if you</li></ul><p>asked for it. </p><p>A note on plotting: if you are using Plots.jl there recipes to directly plot the output of the above multivariate calculations, especially the tuples, in a gridded plot format. See the second jupyter notebook for more details. </p><h2 id="Missing-data-coherences"><a class="docs-heading-anchor" href="#Missing-data-coherences">Missing-data coherences</a><a id="Missing-data-coherences-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-data-coherences" title="Permalink"></a></h2><p>Extending the missing-data spectrum estimation of  <a href="https://academic.oup.com/gji/article-abstract/218/3/2165/5519233">(Chave, 2019)</a>  from the univariate case to the bivariate case, one can compute coherences using the function with signature</p><h3 id="mdmultispec"><a class="docs-heading-anchor" href="#mdmultispec"><code>mdmultispec</code></a><a id="mdmultispec-1"></a><a class="docs-heading-anchor-permalink" href="#mdmultispec" title="Permalink"></a></h3><pre><code class="nohighlight">function mdmultispec(t::Union{Vector{Int64}, Vector{Float64}}, 
                x::Vector{Float64},
                y::Vector{Float64};
                bw::Float64 = 5/length(t),
                k::Int64    = Int64(2*bw*size(x,1) - 1),
                dt::Float64 = 1.0, jk::Bool = true,
                nz::Union{Int64,Float64}   = 0, 
                Ftest::Bool = false,
                lambdau::Union{Tuple{Array{Float64,1},
                               Array{Float64,2}},Nothing} = nothing)</code></pre><p>The inputs are the following:</p><ul><li><code>t</code> – real vector of time</li><li><code>x</code> – first missing-data time series</li><li><code>y</code> – second missing-data time series</li><li><code>bw</code> – bandwidth of estimate, 5/length(t) default</li><li><code>k</code> – number of slepian tapers, must be &lt;=2 bw length(x), 2 bw length(x)-1 default</li><li><code>dt</code> – sampling in time</li><li><code>jk</code> – whether or not to compute jackknife variance estimates</li><li><code>nz</code> – zero padding factor, 0 default</li><li><code>Ftest</code> – whether or not to compute the F-test p-value at all frequencies</li><li><code>lambdau</code> – missing data Slepian tapers and their concentrations, if precomputed</li></ul><p>The output is </p><ul><li><code>sxx</code> – <code>MTCoherence</code> coherence estimate </li></ul><h2 id="Time-domain-statistics"><a class="docs-heading-anchor" href="#Time-domain-statistics">Time domain statistics</a><a id="Time-domain-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Time-domain-statistics" title="Permalink"></a></h2><h3 id="mt_ccvf"><a class="docs-heading-anchor" href="#mt_ccvf">mt_ccvf</a><a id="mt_ccvf-1"></a><a class="docs-heading-anchor-permalink" href="#mt_ccvf" title="Permalink"></a></h3><p>This function computes multitaper estimates of the cross-covariance and cross-correlation by way of inverse-FFT of a multitaper spectrum estimate. Its signature is either</p><p><code>function mt_ccvf(S::MTSpectrum; typ::Symbol = :ccvf)</code></p><p>or</p><pre><code class="nohighlight">mt_ccvf(S1::Vector{T}, S2::Vector{T}; typ::Symbol = :ccvf, NW::Real = 4.0, K::Int = 6, 
                   dt::Float64=1.0, ctr::Bool = true, 
                   pad::Union{Int,Float64} = 1.0, 
                   dpVec::Union{Vector{Float64},Matrix{Float64},Nothing} = nothing,
                   guts::Bool = false, 
                   jk::Bool = false, 
                   Tsq::Union{Vector{Float64},Vector{Vector{Float64}},Vector{Int64},
                   Vector{Vector{Int64}},Nothing}=nothing, 
                   alph::Float64 = 0.05) where T&lt;:Number</code></pre><p>In the first, we assume that you have the MTSpectrum struct handy (must be cross-spectra, coherences won&#39;t work), and in the second you give the two time series, similar to above.  The <code>typ</code> kwarg can take values in (<code>:ccvf</code> and <code>:ccf</code>) with <code>:ccvf</code> being the default value. Depending on the value of typ, you will get one of two different structs</p><ul><li><p><code>MTCrossCorrelationFunction</code>: Contains lags, cross correlation function, and a <a href="../lib/public/#Multitaper.MTParameters"><code>MTParameters</code></a>  struct that carries around the relevant multitaper options. </p></li><li><p><code>MtCrossCovarianceFunction</code>: Contains lags, cross covariance function, and a <a href="../lib/public/#Multitaper.MTParameters"><code>MTParameters</code></a> struct.</p></li></ul><p>when you plot one of the <code>MTCrossCorrelationFunction</code> or <code>MtCrossCovarianceFunction</code> structs using the recipe, you&#39;ll get a stem plot. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../k_univariate/">« Univariate Functions</a><a class="docs-footer-nextpage" href="../lib/public/">Function index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Tuesday 29 June 2021 19:03">Tuesday 29 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
